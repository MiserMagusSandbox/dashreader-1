/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// main.ts
var main_exports = {};
__export(main_exports, {
  default: () => DashReaderPlugin
});
module.exports = __toCommonJS(main_exports);
var import_obsidian7 = require("obsidian");

// src/rsvp-view.ts
var import_obsidian5 = require("obsidian");

// src/services/micropause-service.ts
var _HeadingStrategy = class {
  getMultiplier(word) {
    const trimmed = word.trim();
    const match = trimmed.match(/^\[H(\d)\]/);
    if (!match)
      return 1;
    const level = parseInt(match[1]);
    return _HeadingStrategy.MULTIPLIERS[level] || 1.5;
  }
};
var HeadingStrategy = _HeadingStrategy;
HeadingStrategy.MULTIPLIERS = [0, 2, 1.8, 1.5, 1.3, 1.2, 1.1];
var CalloutStrategy = class {
  constructor(multiplier) {
    this.multiplier = multiplier;
  }
  getMultiplier(word) {
    const trimmed = word.trim();
    return /^\[CALLOUT:[\w-]+\]/.test(trimmed) ? this.multiplier : 1;
  }
};
var SectionMarkerStrategy = class {
  constructor(multiplier) {
    this.multiplier = multiplier;
  }
  getMultiplier(word) {
    const trimmed = word.trim();
    return /^(\d+\.|[IVXLCDM]+\.|\w\.)/.test(trimmed) ? this.multiplier : 1;
  }
};
var ListBulletStrategy = class {
  constructor(multiplier) {
    this.multiplier = multiplier;
  }
  getMultiplier(word) {
    const trimmed = word.trim();
    return /^[-*+•]/.test(trimmed) ? this.multiplier : 1;
  }
};
var SentencePunctuationStrategy = class {
  constructor(multiplier) {
    this.multiplier = multiplier;
  }
  getMultiplier(word) {
    return /[.!?]$/.test(word) ? this.multiplier : 1;
  }
};
var OtherPunctuationStrategy = class {
  constructor(multiplier) {
    this.multiplier = multiplier;
  }
  getMultiplier(word) {
    return /[;:,]$/.test(word) ? this.multiplier : 1;
  }
};
var NumberStrategy = class {
  constructor(multiplier) {
    this.multiplier = multiplier;
  }
  getMultiplier(word) {
    return /\d/.test(word) ? this.multiplier : 1;
  }
};
var LongWordStrategy = class {
  constructor(multiplier) {
    this.multiplier = multiplier;
  }
  getMultiplier(word) {
    return word.length > 8 ? this.multiplier : 1;
  }
};
var ParagraphBreakStrategy = class {
  constructor(multiplier) {
    this.multiplier = multiplier;
  }
  getMultiplier(word) {
    return word.includes("\n") ? this.multiplier : 1;
  }
};
var MicropauseService = class {
  constructor(settings, enabledOverride) {
    this.enabled = enabledOverride != null ? enabledOverride : settings.enableMicropause;
    this.strategies = [
      new HeadingStrategy(),
      new CalloutStrategy(settings.micropauseCallouts),
      new SectionMarkerStrategy(settings.micropauseSectionMarkers),
      new ListBulletStrategy(settings.micropauseListBullets),
      new SentencePunctuationStrategy(settings.micropausePunctuation),
      new OtherPunctuationStrategy(settings.micropauseOtherPunctuation),
      new NumberStrategy(settings.micropauseNumbers),
      new LongWordStrategy(settings.micropauseLongWords),
      new ParagraphBreakStrategy(settings.micropauseParagraph)
    ];
  }
  /**
   * Calculates the total multiplier for a word
   * Applies all strategies and multiplies the results
   *
   * @param word - The word to analyze
   * @returns Total multiplier (1.0 = no pause, >1.0 = longer pause)
   *
   * @example
   * ```typescript
   * const service = new MicropauseService(settings);
   *
   * service.calculateMultiplier("Hello");     // 1.0 (no special characteristics)
   * service.calculateMultiplier("Hello!");    // 2.5 (sentence punctuation)
   * service.calculateMultiplier("[H1]Title"); // 2.0 (heading)
   * service.calculateMultiplier("Hello!\n");  // 6.25 (2.5 * 2.5 = punctuation * paragraph)
   * ```
   */
  calculateMultiplier(word) {
    if (!this.enabled)
      return 1;
    let totalMultiplier = 1;
    for (const strategy of this.strategies) {
      const strategyMultiplier = strategy.getMultiplier(word);
      totalMultiplier *= strategyMultiplier;
    }
    return totalMultiplier;
  }
  /**
   * Updates service with new settings
   * Recreates strategies with updated multipliers
   *
   * @param settings - New settings
   */
  updateSettings(settings, enabledOverride) {
    this.enabled = enabledOverride != null ? enabledOverride : settings.enableMicropause;
    this.strategies = [
      new HeadingStrategy(),
      new CalloutStrategy(settings.micropauseCallouts),
      new SectionMarkerStrategy(settings.micropauseSectionMarkers),
      new ListBulletStrategy(settings.micropauseListBullets),
      new SentencePunctuationStrategy(settings.micropausePunctuation),
      new OtherPunctuationStrategy(settings.micropauseOtherPunctuation),
      new NumberStrategy(settings.micropauseNumbers),
      new LongWordStrategy(settings.micropauseLongWords),
      new ParagraphBreakStrategy(settings.micropauseParagraph)
    ];
  }
};

// src/rsvp-engine.ts
var _RSVPEngine = class {
  constructor(settings, onWordChange, timeoutManager) {
    this.words = [];
    this.currentIndex = 0;
    this.isPlaying = false;
    this.timer = null;
    this.startTime = 0;
    this.startWpm = 0;
    this.pausedTime = 0;
    this.lastPauseTime = 0;
    this.headings = [];
    this.wordsReadInSession = 0;
    // virtual-time history for time-based rewind/forward
    this.history = [];
    this.historyCursor = -1;
    this.playbackMs = 0;
    this.virtualTimeAtIndexMs = [];
    this.virtualTotalMs = 0;
    this.tickGen = 0;
    this.nextDueMs = null;
    // safety cap
    this.useMobileProfile = false;
    this.settings = settings;
    this.onWordChange = onWordChange;
    this.timeoutManager = timeoutManager;
    this.micropauseService = new MicropauseService(settings, this.getEnableMicropauseSetting());
  }
  nowMs() {
    return typeof performance !== "undefined" && typeof performance.now === "function" ? performance.now() : Date.now();
  }
  setText(text, startPosition, startWordIndex) {
    const cleaned = text.replace(/\n+/g, " \xA7\xA7LINEBREAK\xA7\xA7 ").replace(/[ \t]+/g, " ").trim();
    this.words = cleaned.split(/\s+/);
    this.extractHeadings();
    this.words = this.words.map(
      (word) => word === "\xA7\xA7LINEBREAK\xA7\xA7" ? "\n" : word
    );
    this.rebuildVirtualTimeline();
    if (startWordIndex !== void 0) {
      this.currentIndex = Math.max(0, Math.min(startWordIndex, this.words.length - 1));
    } else if (startPosition !== void 0 && startPosition > 0) {
      const textUpToCursor = text.substring(0, startPosition);
      const wordsBeforeCursor = textUpToCursor.trim().split(/\s+/).length;
      this.currentIndex = Math.min(wordsBeforeCursor, this.words.length - 1);
    } else {
      this.currentIndex = 0;
    }
    this.resetHistory();
    this.seedHistoryAtCurrentIndex();
  }
  setUseMobileProfile(useMobile) {
    this.useMobileProfile = useMobile;
    this.micropauseService.updateSettings(this.settings, this.getEnableMicropauseSetting());
    this.rebuildVirtualTimeline();
  }
  play() {
    if (this.isPlaying)
      return;
    if (this.currentIndex >= this.words.length) {
      this.currentIndex = 0;
    }
    this.tickGen += 1;
    this.isPlaying = true;
    this.nextDueMs = null;
    if (this.startTime === 0) {
      this.startTime = Date.now();
      this.startWpm = this.getWpmSetting();
      this.wordsReadInSession = 0;
    } else if (this.lastPauseTime > 0) {
      this.pausedTime += Date.now() - this.lastPauseTime;
      this.lastPauseTime = 0;
    }
    this.displayNextWord();
  }
  pause() {
    this.tickGen += 1;
    this.isPlaying = false;
    if (this.timer !== null) {
      this.timeoutManager.clearTimeout(this.timer);
      this.timer = null;
    }
    this.nextDueMs = null;
    this.lastPauseTime = Date.now();
  }
  stop() {
    this.pause();
    this.nextDueMs = null;
    this.currentIndex = 0;
    this.startTime = 0;
    this.pausedTime = 0;
    this.lastPauseTime = 0;
    this.startWpm = 0;
    this.wordsReadInSession = 0;
    this.resetHistory();
  }
  reset() {
    this.stop();
  }
  resetHistory() {
    this.history = [];
    this.historyCursor = -1;
    this.playbackMs = 0;
  }
  getWpmAtElapsedSeconds(elapsedSec) {
    if (!this.settings.enableAcceleration)
      return this.getWpmSetting();
    const startWpm = this.getWpmSetting();
    const target = this.settings.accelerationTargetWpm;
    const dur = Math.max(1, this.settings.accelerationDuration);
    if (elapsedSec >= dur)
      return Math.round(target);
    const progress = elapsedSec / dur;
    return Math.round(startWpm + (target - startWpm) * progress);
  }
  rebuildVirtualTimeline() {
    const n = this.words.length;
    this.virtualTimeAtIndexMs = new Array(n).fill(0);
    this.virtualTotalMs = 0;
    if (n === 0)
      return;
    let tMs = 0;
    let sessionCount = 0;
    const SLOW_START_WORDS = 5;
    for (let i = 0; i < n; i++) {
      this.virtualTimeAtIndexMs[i] = tMs;
      const w = this.words[i];
      if (w === "\n")
        continue;
      const wpm = this.getWpmAtElapsedSeconds(tMs / 1e3);
      const baseDelay = 60 / wpm * 1e3;
      let delayToken = w;
      if (i + 1 < n && this.words[i + 1] === "\n") {
        delayToken += "\n";
      }
      const mult = this.micropauseService.calculateMultiplier(delayToken);
      let delay = baseDelay * mult;
      if (this.getEnableSlowStartSetting() && sessionCount < SLOW_START_WORDS) {
        const remainingSlowWords = SLOW_START_WORDS - sessionCount;
        const slowStartMultiplier = 1 + remainingSlowWords / SLOW_START_WORDS;
        delay *= slowStartMultiplier;
      }
      sessionCount += 1;
      tMs += Math.max(0, delay);
    }
    this.virtualTotalMs = tMs;
  }
  recordHistory(index, delayMs) {
    if (this.historyCursor < this.history.length - 1) {
      this.history = this.history.slice(0, this.historyCursor + 1);
    }
    const last = this.history[this.history.length - 1];
    if (last && last.index === index && last.tMs === this.playbackMs) {
      this.playbackMs += Math.max(0, delayMs);
      return;
    }
    this.history.push({ index, tMs: this.playbackMs });
    this.historyCursor = this.history.length - 1;
    this.playbackMs += Math.max(0, delayMs);
    while (this.history.length > _RSVPEngine.MAX_HISTORY_ENTRIES || this.history.length > 0 && this.playbackMs - this.history[0].tMs > _RSVPEngine.MAX_HISTORY_MS) {
      this.history.shift();
      this.historyCursor -= 1;
    }
    if (this.historyCursor < -1)
      this.historyCursor = -1;
  }
  getCursorTimeMs() {
    if (this.history.length === 0 || this.historyCursor < 0)
      return 0;
    return this.history[this.historyCursor].tMs;
  }
  findLastAtOrBefore(tMs) {
    if (this.history.length === 0)
      return -1;
    let lo = 0, hi = this.history.length - 1, ans = -1;
    while (lo <= hi) {
      const mid = lo + hi >> 1;
      if (this.history[mid].tMs <= tMs) {
        ans = mid;
        lo = mid + 1;
      } else {
        hi = mid - 1;
      }
    }
    return ans;
  }
  findFirstAtOrAfter(tMs) {
    if (this.history.length === 0)
      return -1;
    let lo = 0, hi = this.history.length - 1, ans = -1;
    while (lo <= hi) {
      const mid = lo + hi >> 1;
      if (this.history[mid].tMs >= tMs) {
        ans = mid;
        hi = mid - 1;
      } else {
        lo = mid + 1;
      }
    }
    return ans;
  }
  seekToHistoryCursor(cursor) {
    if (cursor < 0 || cursor >= this.history.length)
      return;
    this.historyCursor = cursor;
    this.currentIndex = this.history[cursor].index;
    this.playbackMs = this.history[cursor].tMs;
  }
  isSentenceBoundaryToken(word) {
    if (!word)
      return false;
    if (word === "\n")
      return true;
    if (/^\[H\d\]/.test(word) || /^\[CALLOUT:/.test(word))
      return true;
    return /[.!?]["')\]]?$/.test(word);
  }
  alignToSentenceStart(index) {
    let i = Math.max(0, Math.min(index, this.words.length - 1));
    while (i > 0 && !this.isSentenceBoundaryToken(this.words[i - 1]))
      i -= 1;
    while (i < this.words.length && this.words[i] === "\n")
      i += 1;
    return i;
  }
  rewind(steps = 20) {
    this.moveByWords(-steps);
    if (this.isPlaying) {
      this.pause();
      this.play();
    } else {
      this.displayCurrentWord();
    }
  }
  forward(steps = 20) {
    this.moveByWords(steps);
    if (this.isPlaying) {
      this.pause();
      this.play();
    } else {
      this.displayCurrentWord();
    }
  }
  moveByWords(wordDelta) {
    if (this.words.length === 0 || wordDelta === 0)
      return;
    let i = this.currentIndex;
    if (wordDelta < 0) {
      while (i > 0 && this.words[i] === "\n")
        i -= 1;
    } else {
      while (i < this.words.length && this.words[i] === "\n")
        i += 1;
    }
    let remaining = Math.abs(wordDelta);
    if (wordDelta < 0) {
      while (i > 0 && remaining > 0) {
        i -= 1;
        if (this.words[i] !== "\n")
          remaining -= 1;
      }
      while (i > 0 && this.words[i] === "\n")
        i -= 1;
    } else {
      while (i < this.words.length - 1 && remaining > 0) {
        i += 1;
        if (this.words[i] !== "\n")
          remaining -= 1;
      }
      while (i < this.words.length - 1 && this.words[i] === "\n")
        i += 1;
    }
    this.currentIndex = Math.max(0, Math.min(i, this.words.length - 1));
  }
  rewindSeconds(seconds = 10, snapToSentence = false) {
    var _a, _b, _c, _d;
    const wasPlaying = this.isPlaying;
    if (wasPlaying)
      this.pause();
    const curMs = this.history.length > 0 && this.historyCursor >= 0 ? this.history[this.historyCursor].tMs : (_a = this.virtualTimeAtIndexMs[this.currentIndex]) != null ? _a : 0;
    const targetMs = Math.max(0, curMs - seconds * 1e3);
    const canUseHistory = this.history.length >= 2 && this.historyCursor >= 0 && this.history[0].tMs <= targetMs;
    if (!canUseHistory) {
      this.currentIndex = this.findVirtualIndexAtOrBeforeMs(targetMs);
      if (snapToSentence)
        this.currentIndex = this.alignToSentenceStart(this.currentIndex);
      this.resetHistory();
      this.seedHistoryAtCurrentIndex();
      if (wasPlaying)
        this.play();
      else
        this.displayCurrentWord();
      return;
    }
    const cursor = this.findLastAtOrBefore(targetMs);
    if (cursor === -1) {
      this.currentIndex = this.findVirtualIndexAtOrBeforeMs(targetMs);
      if (snapToSentence)
        this.currentIndex = this.alignToSentenceStart(this.currentIndex);
      this.resetHistory();
      this.seedHistoryAtCurrentIndex();
      if (wasPlaying)
        this.play();
      else
        this.displayCurrentWord();
      return;
    }
    this.seekToHistoryCursor(cursor);
    if (snapToSentence) {
      const aligned = this.alignToSentenceStart(this.currentIndex);
      if (this.history.length > 0 && aligned < this.history[0].index) {
        this.currentIndex = aligned;
        this.resetHistory();
        this.seedHistoryAtCurrentIndex();
      } else {
        while (this.historyCursor > 0 && this.history[this.historyCursor].index > aligned) {
          this.historyCursor -= 1;
        }
        this.currentIndex = aligned;
        this.playbackMs = (_d = (_b = this.history[this.historyCursor]) == null ? void 0 : _b.tMs) != null ? _d : (_c = this.virtualTimeAtIndexMs[this.currentIndex]) != null ? _c : 0;
      }
    }
    if (wasPlaying)
      this.play();
    else
      this.displayCurrentWord();
  }
  forwardSeconds(seconds = 10) {
    var _a;
    const wasPlaying = this.isPlaying;
    if (wasPlaying)
      this.pause();
    if (this.history.length < 2) {
      const curMs = (_a = this.virtualTimeAtIndexMs[this.currentIndex]) != null ? _a : 0;
      const targetMs = curMs + seconds * 1e3;
      this.currentIndex = this.findVirtualIndexAtOrAfterMs(targetMs);
      this.resetHistory();
      this.seedHistoryAtCurrentIndex();
      if (wasPlaying)
        this.play();
      else
        this.displayCurrentWord();
      return;
    }
    if (this.history.length > 0 && this.historyCursor >= 0 && this.historyCursor < this.history.length - 1) {
      const target = this.getCursorTimeMs() + seconds * 1e3;
      const nextCursor = this.findFirstAtOrAfter(target);
      this.seekToHistoryCursor(nextCursor !== -1 ? nextCursor : this.history.length - 1);
      if (wasPlaying)
        this.play();
      else
        this.displayCurrentWord();
      return;
    }
    let acc = 0;
    let i = this.currentIndex;
    let sessionCount = this.wordsReadInSession;
    const SLOW_START_WORDS = 5;
    while (i < this.words.length && acc < seconds * 1e3) {
      if (this.words[i] === "\n") {
        i += 1;
        continue;
      }
      let delay = this.getChunk(i).delay;
      if (this.getEnableSlowStartSetting() && sessionCount < SLOW_START_WORDS) {
        const remainingSlowWords = SLOW_START_WORDS - sessionCount;
        const slowStartMultiplier = 1 + remainingSlowWords / SLOW_START_WORDS;
        delay *= slowStartMultiplier;
      }
      acc += delay;
      sessionCount += 1;
      i += 1;
    }
    this.currentIndex = Math.min(this.words.length - 1, i);
    const newT = this.playbackMs + acc;
    if (this.historyCursor < this.history.length - 1) {
      this.history = this.history.slice(0, this.historyCursor + 1);
    }
    this.playbackMs = newT;
    this.history.push({ index: this.currentIndex, tMs: this.playbackMs });
    this.historyCursor = this.history.length - 1;
    while (this.history.length > _RSVPEngine.MAX_HISTORY_ENTRIES || this.history.length > 0 && this.playbackMs - this.history[0].tMs > _RSVPEngine.MAX_HISTORY_MS) {
      this.history.shift();
      this.historyCursor -= 1;
    }
    if (this.historyCursor < -1)
      this.historyCursor = -1;
    if (wasPlaying)
      this.play();
    else
      this.displayCurrentWord();
  }
  getWpmSetting() {
    return this.useMobileProfile ? this.settings.mobileWpm : this.settings.wpm;
  }
  setWpmSetting(v) {
    if (this.useMobileProfile)
      this.settings.mobileWpm = v;
    else
      this.settings.wpm = v;
  }
  getChunkSizeSetting() {
    return this.useMobileProfile ? this.settings.mobileChunkSize : this.settings.chunkSize;
  }
  setChunkSizeSetting(v) {
    if (this.useMobileProfile)
      this.settings.mobileChunkSize = v;
    else
      this.settings.chunkSize = v;
  }
  getEnableSlowStartSetting() {
    return this.useMobileProfile ? this.settings.mobileEnableSlowStart : this.settings.enableSlowStart;
  }
  getEnableMicropauseSetting() {
    return this.useMobileProfile ? this.settings.mobileEnableMicropause : this.settings.enableMicropause;
  }
  displayCurrentWord() {
    while (this.currentIndex < this.words.length && this.words[this.currentIndex] === "\n") {
      this.currentIndex += 1;
    }
    if (this.currentIndex >= this.words.length) {
      return;
    }
    const chunk = this.getChunk(this.currentIndex);
    this.onWordChange(chunk);
  }
  displayNextWord() {
    if (!this.isPlaying)
      return;
    const gen = this.tickGen;
    while (this.currentIndex < this.words.length && this.words[this.currentIndex] === "\n") {
      this.currentIndex += 1;
    }
    if (this.currentIndex >= this.words.length) {
      this.isPlaying = false;
      return;
    }
    const chunk = this.getChunk(this.currentIndex);
    this.onWordChange(chunk);
    let delay = chunk.delay;
    if (this.getEnableSlowStartSetting()) {
      const SLOW_START_WORDS = 5;
      if (this.wordsReadInSession < SLOW_START_WORDS) {
        const remainingSlowWords = SLOW_START_WORDS - this.wordsReadInSession;
        const slowStartMultiplier = 1 + remainingSlowWords / SLOW_START_WORDS;
        delay *= slowStartMultiplier;
      }
    }
    this.wordsReadInSession += 1;
    this.recordHistory(this.currentIndex, delay);
    this.currentIndex += 1;
    const now = this.nowMs();
    const delayMs = Math.max(0, delay);
    if (this.nextDueMs == null)
      this.nextDueMs = now;
    this.nextDueMs += delayMs;
    let waitMs = this.nextDueMs - now;
    if (waitMs < -250) {
      this.nextDueMs = now + delayMs;
      waitMs = delayMs;
    }
    this.timer = this.timeoutManager.setTimeout(() => {
      if (gen !== this.tickGen)
        return;
      this.displayNextWord();
    }, Math.max(0, waitMs));
  }
  getChunk(startIndex) {
    var _a;
    const chunkSize = Math.max(1, this.getChunkSizeSetting() || 1);
    const chunkWords = [];
    let i = startIndex;
    while (i < this.words.length && chunkWords.length < chunkSize) {
      const w = this.words[i];
      if (w !== "\n")
        chunkWords.push(w);
      i++;
    }
    const text = chunkWords.join(" ");
    const focusWordRaw = (_a = chunkWords[0]) != null ? _a : "";
    let delayToken = focusWordRaw;
    if (startIndex + 1 < this.words.length && this.words[startIndex + 1] === "\n") {
      delayToken += "\n";
    }
    const delay = this.calculateDelay(delayToken);
    return {
      text,
      index: startIndex,
      delay,
      isEnd: startIndex >= this.words.length - 1,
      headingContext: this.getCurrentHeadingContext(startIndex)
    };
  }
  getCurrentWpm() {
    if (!this.settings.enableAcceleration || this.startTime === 0) {
      return this.getWpmSetting();
    }
    const now = this.isPlaying ? Date.now() : this.lastPauseTime || Date.now();
    const elapsed = (now - this.startTime - this.pausedTime) / 1e3;
    if (elapsed >= this.settings.accelerationDuration) {
      return this.settings.accelerationTargetWpm;
    }
    const progress = elapsed / this.settings.accelerationDuration;
    const wpmDiff = this.settings.accelerationTargetWpm - this.startWpm;
    const currentWpm = this.startWpm + wpmDiff * progress;
    return Math.round(currentWpm);
  }
  calculateDelay(text) {
    const currentWpm = this.getCurrentWpm();
    const baseDelay = 60 / currentWpm * 1e3;
    const multiplier = this.micropauseService.calculateMultiplier(text);
    return baseDelay * multiplier;
  }
  /**
   * Extract all headings and callouts from the words array
   * Headings are marked with [H1], [H2], etc.
   * Callouts are marked with [CALLOUT:type] by the markdown parser
   *
   * Since text is split into words, we need to collect all words
   * that belong to the same heading/callout title.
   */
  extractHeadings() {
    this.headings = [];
    for (let i = 0; i < this.words.length; i++) {
      const word = this.words[i];
      const headingMatch = word.match(/^\[H(\d)\](.+)/);
      if (headingMatch) {
        const level = parseInt(headingMatch[1]);
        const firstWord = headingMatch[2];
        const titleWords = [firstWord];
        let j = i + 1;
        while (j < this.words.length) {
          const nextWord = this.words[j];
          if (nextWord === "\xA7\xA7LINEBREAK\xA7\xA7") {
            break;
          }
          if (/^\[H\d\]/.test(nextWord) || /^\[CALLOUT:/.test(nextWord)) {
            break;
          }
          titleWords.push(nextWord);
          j++;
          if (titleWords.length >= 20) {
            break;
          }
        }
        const text = titleWords.join(" ").trim();
        this.headings.push({
          level,
          text,
          wordIndex: i
        });
        continue;
      }
      const calloutMatch = word.match(/^\[CALLOUT:([\w-]+)\](.+)/);
      if (calloutMatch) {
        const calloutType = calloutMatch[1];
        const firstWord = calloutMatch[2];
        const titleWords = [firstWord];
        let j = i + 1;
        while (j < this.words.length) {
          const nextWord = this.words[j];
          if (nextWord === "\xA7\xA7LINEBREAK\xA7\xA7") {
            break;
          }
          if (/^\[H\d\]/.test(nextWord) || /^\[CALLOUT:/.test(nextWord)) {
            break;
          }
          titleWords.push(nextWord);
          j++;
          if (titleWords.length >= 20) {
            break;
          }
        }
        const text = titleWords.join(" ").trim();
        this.headings.push({
          level: 7,
          // Callouts are LOWER priority than H6 (H1..H6)
          text,
          wordIndex: i,
          calloutType
        });
      }
    }
  }
  /**
   * Get the current heading context (breadcrumb) for a given word index
   * Returns the hierarchical path of headings leading to the current position
   *
   * @param wordIndex - Word index to get context for
   * @returns Heading context with breadcrumb path and current heading
   */
  getCurrentHeadingContext(wordIndex) {
    if (this.headings.length === 0) {
      return { breadcrumb: [], current: null };
    }
    const relevantHeadings = this.headings.filter((h) => h.wordIndex <= wordIndex);
    if (relevantHeadings.length === 0) {
      return { breadcrumb: [], current: null };
    }
    const breadcrumb = [];
    let currentLevel = 0;
    for (const heading of relevantHeadings) {
      if (heading.level <= currentLevel) {
        while (breadcrumb.length > 0 && breadcrumb[breadcrumb.length - 1].level >= heading.level) {
          breadcrumb.pop();
        }
      }
      breadcrumb.push(heading);
      currentLevel = heading.level;
    }
    return {
      breadcrumb,
      current: breadcrumb[breadcrumb.length - 1] || null
    };
  }
  getProgress() {
    return this.words.length > 0 ? this.currentIndex / this.words.length * 100 : 0;
  }
  getCurrentIndex() {
    return this.currentIndex;
  }
  getTotalWords() {
    return this.words.length;
  }
  getIsPlaying() {
    return this.isPlaying;
  }
  setWpm(wpm) {
    this.setWpmSetting(Math.max(50, Math.min(5e3, wpm)));
    this.rebuildVirtualTimeline();
  }
  getWpm() {
    return this.getWpmSetting();
  }
  setChunkSize(size) {
    this.setChunkSizeSetting(Math.max(1, Math.min(5, size)));
  }
  getChunkSize() {
    return this.getChunkSizeSetting();
  }
  // ---------------------------------------------------------------------------
  // Line-based context (replaces old word-based context)
  // ---------------------------------------------------------------------------
  isLineBreakToken(t) {
    return t === "\n" || t === "\xA7\xA7LINEBREAK\xA7\xA7";
  }
  findLineStart(index) {
    let i = Math.max(0, Math.min(index, this.words.length));
    while (i > 0 && !this.isLineBreakToken(this.words[i - 1]))
      i--;
    return i;
  }
  findLineEnd(index) {
    let i = Math.max(0, Math.min(index, this.words.length));
    while (i < this.words.length && !this.isLineBreakToken(this.words[i]))
      i++;
    return i;
  }
  getPrevLineRange(currentLineStart) {
    let sep = currentLineStart - 1;
    if (sep < 0)
      return null;
    const end = sep;
    while (sep > 0 && !this.isLineBreakToken(this.words[sep - 1]))
      sep--;
    const start = sep;
    return { start, end, prevSeparator: start - 1 };
  }
  getNextLineRange(currentLineEnd) {
    if (currentLineEnd >= this.words.length)
      return null;
    const start = currentLineEnd + 1;
    if (start > this.words.length)
      return null;
    let end = start;
    while (end < this.words.length && !this.isLineBreakToken(this.words[end]))
      end++;
    return { start, end, nextSeparator: end };
  }
  getActiveChunkEndOnThisLine(startIndex) {
    const chunkSize = Math.max(1, this.getChunkSizeSetting() || 1);
    const lineEnd = this.findLineEnd(startIndex);
    let count = 0;
    let i = startIndex;
    let last = startIndex;
    while (i < lineEnd && count < chunkSize) {
      const w = this.words[i];
      if (!this.isLineBreakToken(w)) {
        last = i;
        count++;
      }
      i++;
    }
    return last;
  }
  /**
   * Returns line-based context around the active chunk:
   * - BEFORE: N full lines above + anchor-before (words before active chunk on current line)
   * - AFTER : anchor-after (words after active chunk on current line) + N full lines below
   *
   * `lines` is 0..10 (0 means anchor line only).
   */
  getContextLines(startIndex, lines) {
    const idx = Math.max(0, Math.min(startIndex, this.words.length - 1));
    const n = Math.max(0, Math.floor(lines));
    const lineStart = this.findLineStart(idx);
    const lineEnd = this.findLineEnd(idx);
    const chunkEnd = this.getActiveChunkEndOnThisLine(idx);
    const anchorBefore = this.words.slice(lineStart, idx).filter((t) => !this.isLineBreakToken(t));
    const anchorAfter = this.words.slice(idx + 1, lineEnd).filter((t) => !this.isLineBreakToken(t));
    const aboveLines = [];
    let cursorStart = lineStart;
    for (let k = 0; k < n; k++) {
      const prev = this.getPrevLineRange(cursorStart);
      if (!prev)
        break;
      aboveLines.unshift(this.words.slice(prev.start, prev.end).filter((t) => !this.isLineBreakToken(t)));
      cursorStart = prev.start;
    }
    const belowLines = [];
    let cursorEnd = lineEnd;
    for (let k = 0; k < n; k++) {
      const next = this.getNextLineRange(cursorEnd);
      if (!next)
        break;
      belowLines.push(this.words.slice(next.start, next.end).filter((t) => !this.isLineBreakToken(t)));
      cursorEnd = next.end;
    }
    const before = [];
    for (let i = 0; i < aboveLines.length; i++) {
      before.push(...aboveLines[i]);
      before.push("\n");
    }
    before.push(...anchorBefore);
    const after = [];
    after.push(...anchorAfter);
    for (let i = 0; i < belowLines.length; i++) {
      after.push("\n");
      after.push(...belowLines[i]);
    }
    return { before, after };
  }
  /**
   * Returns a token window around the current word for UI-level (wrapped) context rendering.
   * Includes explicit line break tokens ('\n') and internal markers; the view layer formats it.
   */
  getContextTokenWindow(index, backTokens, forwardTokens) {
    const len = this.words.length;
    if (len === 0)
      return { before: [], after: [] };
    const idx = Math.max(0, Math.min(index, len - 1));
    const back = Math.max(0, Math.floor(backTokens));
    const fwd = Math.max(0, Math.floor(forwardTokens));
    const start = Math.max(0, idx - back);
    const before = this.words.slice(start, idx);
    while (before.length && before[before.length - 1] === "\n")
      before.pop();
    let afterStart = Math.min(len, idx + 1);
    while (afterStart < len && this.words[afterStart] === "\n")
      afterStart += 1;
    const end = Math.min(len, afterStart + fwd);
    const after = this.words.slice(afterStart, end);
    return { before, after };
  }
  getVirtualTotalSeconds() {
    return Math.round(this.virtualTotalMs / 1e3);
  }
  getVirtualElapsedSecondsAtCurrentIndex() {
    if (this.words.length === 0)
      return 0;
    const idx = Math.max(0, Math.min(this.currentIndex, this.words.length - 1));
    return Math.round((this.virtualTimeAtIndexMs[idx] || 0) / 1e3);
  }
  getVirtualRemainingSeconds() {
    const total = this.getVirtualTotalSeconds();
    const elapsed = this.getVirtualElapsedSecondsAtCurrentIndex();
    return Math.max(0, total - elapsed);
  }
  getVirtualElapsedSecondsAtIndex(index) {
    if (this.words.length === 0)
      return 0;
    const idx = Math.max(0, Math.min(index, this.words.length - 1));
    return Math.round((this.virtualTimeAtIndexMs[idx] || 0) / 1e3);
  }
  findVirtualIndexAtOrBeforeMs(tMs) {
    const n = this.words.length;
    if (n === 0)
      return 0;
    let lo = 0, hi = n - 1, ans = 0;
    while (lo <= hi) {
      const mid = lo + hi >> 1;
      if (this.virtualTimeAtIndexMs[mid] <= tMs) {
        ans = mid;
        lo = mid + 1;
      } else
        hi = mid - 1;
    }
    return ans;
  }
  findVirtualIndexAtOrAfterMs(tMs) {
    const n = this.words.length;
    if (n === 0)
      return 0;
    let lo = 0, hi = n - 1, ans = n - 1;
    while (lo <= hi) {
      const mid = lo + hi >> 1;
      if (this.virtualTimeAtIndexMs[mid] >= tMs) {
        ans = mid;
        hi = mid - 1;
      } else
        lo = mid + 1;
    }
    return ans;
  }
  seedHistoryAtCurrentIndex() {
    var _a;
    const tMs = (_a = this.virtualTimeAtIndexMs[this.currentIndex]) != null ? _a : 0;
    this.playbackMs = tMs;
    this.history = [{ index: this.currentIndex, tMs }];
    this.historyCursor = 0;
  }
  updateSettings(settings) {
    this.settings = settings;
    this.micropauseService.updateSettings(settings, this.getEnableMicropauseSetting());
    this.rebuildVirtualTimeline();
  }
  getEstimatedDuration() {
    return this.getVirtualRemainingSeconds();
  }
  calculateAccurateRemainingTime(wpm) {
    if (this.words.length === 0 || this.currentIndex >= this.words.length)
      return 0;
    let totalTimeMs = 0;
    const baseDelay = 60 / wpm * 1e3;
    for (let i = this.currentIndex; i < this.words.length; i++) {
      const word = this.words[i];
      const multiplier = this.micropauseService.calculateMultiplier(word);
      totalTimeMs += baseDelay * multiplier;
    }
    return Math.ceil(totalTimeMs / 1e3);
  }
  getRemainingWords() {
    return Math.max(0, this.words.length - this.currentIndex);
  }
  getElapsedTime() {
    if (this.startTime === 0)
      return 0;
    const now = this.isPlaying ? Date.now() : this.lastPauseTime || Date.now();
    return Math.floor((now - this.startTime - this.pausedTime) / 1e3);
  }
  getRemainingTime() {
    return this.getVirtualRemainingSeconds();
  }
  getCurrentWpmPublic() {
    return this.getCurrentWpm();
  }
  /**
   * Returns all headings extracted from the document
   * Useful for navigation and section counting
   */
  getHeadings() {
    return this.headings;
  }
  jumpToIndex(index) {
    if (this.words.length === 0)
      return;
    this.currentIndex = Math.max(0, Math.min(index, this.words.length - 1));
    this.resetHistory();
    this.seedHistoryAtCurrentIndex();
    if (this.isPlaying) {
      this.pause();
      this.play();
    } else {
      this.displayCurrentWord();
    }
  }
  /**
   * Move by N real words (skipping '\n' tokens).
   * Negative = backward, positive = forward.
   * Keeps behavior consistent with jumpToIndex() (updates display / restarts timer if playing).
   */
  stepWords(wordDelta) {
    if (this.words.length === 0 || wordDelta === 0)
      return;
    this.moveByWords(wordDelta);
    this.resetHistory();
    this.seedHistoryAtCurrentIndex();
    if (this.isPlaying) {
      this.pause();
      this.play();
    } else {
      this.displayCurrentWord();
    }
  }
  jumpToStart() {
    this.jumpToIndex(0);
  }
  jumpToEnd() {
    this.jumpToIndex(this.words.length - 1);
  }
};
var RSVPEngine = _RSVPEngine;
RSVPEngine.MAX_HISTORY_MS = 10 * 6e4;
// keep ~10 minutes
RSVPEngine.MAX_HISTORY_ENTRIES = 2e4;

// src/markdown-parser.ts
var MarkdownParser = class {
  static parseToPlainText(markdown) {
    let text = markdown;
    text = text.replace(/^---[\s\S]*?---\n?/m, "");
    const codeBlocks = [];
    text = text.replace(/```[\w-]*\n?([\s\S]*?)```/g, (_match, code) => {
      const index = codeBlocks.length;
      codeBlocks.push(code);
      return `___CODE_BLOCK_${index}___`;
    });
    text = text.replace(/`([^`]+)`/g, "$1");
    text = text.replace(/!\[([^\]]*)\]\([^)]+\)/g, "");
    text = text.replace(/\[([^\]]+)\]\([^)]+\)/g, "$1");
    text = text.replace(/\[\[([^\]|]+)(\|([^\]]+))?\]\]/g, (_match, link, _pipe, alias) => {
      return alias || link;
    });
    text = text.replace(/\*\*\*([^*]+)\*\*\*/g, "$1");
    text = text.replace(/\*\*([^*]+)\*\*/g, "$1");
    text = text.replace(/__([^_]+)__/g, "$1");
    text = text.replace(/\*([^*\n]+)\*/g, "$1");
    text = text.replace(/_([^_\n]+)_/g, "$1");
    text = text.replace(/~~([^~]+)~~/g, "$1");
    text = text.replace(/==([^=]+)==/g, "$1");
    text = text.replace(/^(#{1,6})\s+(.+)$/gm, (_match, hashes, content) => {
      const level = hashes.length;
      return `[H${level}]${content}`;
    });
    text = text.replace(/^>\s*\[!([\w-]+)\]\s*(.*)$/gm, (_match, type, title) => {
      const displayTitle = title.trim() || type;
      return `[CALLOUT:${type}]${displayTitle}`;
    });
    text = text.replace(/^>\s*/gm, "");
    text = text.replace(/^[\s]*[-*+]\s+/gm, "");
    text = text.replace(/^[\s]*\d+\.\s+/gm, "");
    text = text.replace(/^[\s]*[-*_]{3,}[\s]*$/gm, "");
    text = text.replace(/\[\^[^\]]+\]/g, "");
    text = text.replace(/^\[\^[^\]]+\]:.*$/gm, "");
    text = text.replace(/^---\s*Backlinks?\s*---[\s\S]*$/m, "");
    text = text.replace(/^##?\s*Backlinks?[\s\S]*$/m, "");
    text = text.replace(/<!--[\s\S]*?-->/g, "");
    text = text.replace(/<[^>]+>/g, "");
    text = text.replace(/\n{3,}/g, "\n\n");
    text = text.replace(/^[ \t]+/gm, "");
    text = text.replace(/[ \t]+$/gm, "");
    text = text.replace(/___CODE_BLOCK_(\d+)___/g, (_match, index) => {
      return codeBlocks[parseInt(index)] || "";
    });
    text = text.trim();
    return text;
  }
  /**
   * Parse le texte sélectionné en tenant compte du contexte Obsidian
   */
  static parseSelection(text) {
    return this.parseToPlainText(text);
  }
};

// src/view-state.ts
var DEFAULT_VIEW_STATE = {
  wordsRead: 0,
  startTime: 0,
  showingControls: false,
  showingSettings: false,
  currentWpm: 0,
  currentChunkSize: 0,
  currentFontSize: 0,
  isLoading: false
};
var ViewState = class {
  /**
   * Creates a new ViewState instance
   *
   * @param initialState - Optional partial state to merge with defaults
   *
   * @example
   * ```typescript
   * // Default state
   * const state = new ViewState();
   *
   * // With initial values
   * const state = new ViewState({
   *   currentWpm: 300,
   *   showingControls: true
   * });
   * ```
   */
  constructor(initialState = {}) {
    this.listeners = /* @__PURE__ */ new Set();
    this.state = { ...DEFAULT_VIEW_STATE, ...initialState };
  }
  /**
   * Get a state value (type-safe)
   *
   * Uses TypeScript generics to ensure return type matches the requested key.
   *
   * @param key - State property to get
   * @returns Current value of the property
   *
   * @example
   * ```typescript
   * const wpm: number = state.get('currentWpm');
   * const showing: boolean = state.get('showingControls');
   * ```
   */
  get(key) {
    return this.state[key];
  }
  /**
   * Set a state value and notify listeners (type-safe)
   *
   * Updates the state property and notifies all subscribers if the value changed.
   * Automatically skips notification if the new value equals the old value.
   *
   * @param key - State property to set
   * @param value - New value for the property
   *
   * @example
   * ```typescript
   * state.set('currentWpm', 350);
   * state.set('showingControls', true);
   * state.set('loadedFileName', 'My Note.md');
   * ```
   */
  set(key, value) {
    const oldValue = this.state[key];
    if (oldValue === value)
      return;
    this.state[key] = value;
    this.notify(key, value, oldValue);
  }
  /**
   * Update multiple state values at once (batch update)
   *
   * Efficiently updates multiple properties in a single call. Each changed
   * property will trigger its own notification to listeners.
   *
   * @param updates - Partial state object with properties to update
   *
   * @example
   * ```typescript
   * state.update({
   *   currentWpm: 350,
   *   showingControls: true,
   *   wordsRead: 42
   * });
   * ```
   */
  update(updates) {
    Object.entries(updates).forEach(([key, value]) => {
      this.set(key, value);
    });
  }
  /**
   * Reset all state to default values
   *
   * Sets every state property back to its default value from DEFAULT_VIEW_STATE.
   * Each reset property triggers a notification to listeners.
   *
   * @example
   * ```typescript
   * // After reading session, reset to defaults
   * state.reset();
   * ```
   */
  reset() {
    Object.entries(DEFAULT_VIEW_STATE).forEach(([key, value]) => {
      this.set(key, value);
    });
  }
  /**
   * Subscribe to state changes (observer pattern)
   *
   * Registers a listener function that will be called whenever any state
   * property changes. Returns an unsubscribe function for cleanup.
   *
   * **Error Handling**: Listener errors are caught and logged to prevent
   * one broken listener from breaking all listeners.
   *
   * @param listener - Callback function to call on state changes
   * @returns Unsubscribe function to remove the listener
   *
   * @example
   * ```typescript
   * // Subscribe and get unsubscribe function
   * const unsubscribe = state.subscribe((key, value, oldValue) => {
   *   if (key === 'currentWpm') {
   *     console.log(`WPM changed from ${oldValue} to ${value}`);
   *   }
   * });
   *
   * // Later, cleanup
   * unsubscribe();
   * ```
   */
  subscribe(listener) {
    this.listeners.add(listener);
    return () => this.listeners.delete(listener);
  }
  /**
   * Notify all listeners of a state change (internal)
   *
   * Calls each registered listener with the changed property details.
   * Catches and logs errors to prevent one broken listener from affecting others.
   *
   * @param key - Name of the property that changed
   * @param value - New value of the property
   * @param oldValue - Previous value of the property
   *
   * @private
   */
  notify(key, value, oldValue) {
    this.listeners.forEach((listener) => {
      try {
        listener(key, value, oldValue);
      } catch (error) {
        console.error("DashReader: Error in state listener", error);
      }
    });
  }
  /**
   * Get all state as a plain object (for debugging)
   *
   * Returns a shallow copy of the entire state object. Useful for logging
   * or debugging state issues.
   *
   * @returns Readonly copy of the full state
   *
   * @example
   * ```typescript
   * console.log('Current state:', state.getAll());
   * // Output: { wordsRead: 42, currentWpm: 350, showingControls: true, ... }
   * ```
   */
  getAll() {
    return { ...this.state };
  }
  /**
   * Toggle a boolean state value (helper)
   *
   * Convenience method for toggling boolean properties. Flips the value
   * from true to false or false to true.
   *
   * @param key - Boolean property to toggle (showingControls, showingSettings, isLoading)
   *
   * @example
   * ```typescript
   * // Toggle control panel visibility
   * state.toggle('showingControls');
   *
   * // Toggle settings panel
   * state.toggle('showingSettings');
   * ```
   */
  toggle(key) {
    const currentValue = this.get(key);
    this.set(key, !currentValue);
  }
  /**
   * Increment a numeric state value (helper)
   *
   * Convenience method for incrementing numeric properties. Can add positive
   * or negative deltas.
   *
   * @param key - Numeric property to increment (currently only wordsRead)
   * @param delta - Amount to add (default: 1, can be negative)
   *
   * @example
   * ```typescript
   * // Increment words read by 1
   * state.increment('wordsRead');
   *
   * // Increment by 5
   * state.increment('wordsRead', 5);
   *
   * // Decrement by 1
   * state.increment('wordsRead', -1);
   * ```
   */
  increment(key, delta = 1) {
    const currentValue = this.get(key);
    this.set(key, currentValue + delta);
  }
};

// src/constants.ts
var CSS_CLASSES = {
  // Main container
  container: "dashreader-container",
  // Toggle bar
  toggleBar: "dashreader-toggle-bar",
  toggleBtn: "dashreader-toggle-btn",
  // Display area
  display: "dashreader-display",
  word: "dashreader-word",
  welcome: "dashreader-welcome",
  highlight: "dashreader-highlight",
  // Context
  contextBefore: "dashreader-context-before",
  contextAfter: "dashreader-context-after",
  // Progress
  progressContainer: "dashreader-progress-container",
  progressBar: "dashreader-progress-bar",
  // Controls
  controls: "dashreader-controls",
  controlGroup: "dashreader-control-group",
  controlLabel: "control-label",
  // Settings
  settings: "dashreader-settings",
  settingGroup: "dashreader-setting-group",
  settingLabel: "setting-label",
  settingToggle: "setting-toggle",
  // Buttons
  btn: "dashreader-btn",
  playBtn: "play-btn",
  pauseBtn: "pause-btn",
  smallBtn: "small-btn",
  // Value displays
  wpmValue: "wpm-value",
  wpmInlineValue: "wpm-inline-value",
  chunkValue: "chunk-value",
  fontValue: "font-value",
  accelDurationValue: "accel-duration-value",
  accelTargetValue: "accel-target-value",
  // State classes
  hidden: "hidden"
};
var TIMING = {
  /** Delay before auto-loading content from editor (file-open event) */
  autoLoadDelay: 300,
  /** Shorter delay for leaf-change events (editor already active) */
  autoLoadDelayShort: 200,
  /** Very short delay for immediate operations */
  autoLoadDelayVeryShort: 50,
  /** Throttle interval for cursor/selection checks (prevents excessive checks) */
  throttleDelay: 150,
  /** CSS transition duration for smooth animations */
  transitionDuration: 300
};
var TEXT_LIMITS = {
  /** Minimum characters in selection to trigger auto-load */
  minSelectionLength: 30,
  /** Minimum characters in full document to load */
  minContentLength: 50,
  /** Minimum words in parsed text to display */
  minParsedLength: 10
};
var INCREMENTS = {
  /** WPM increment (25 = noticeable speed change) */
  wpm: 25,
  /** Chunk size increment (1 word at a time) */
  chunkSize: 1,
  /** Font size increment in pixels (4px = visible change) */
  fontSize: 4,
  /** Acceleration duration increment in seconds */
  accelDuration: 5,
  contextLines: 1,
  contextFontSize: 1
};
var LIMITS = {
  /** Font size range in pixels (20 = readable minimum, 120 = fills viewport) */
  fontSize: { min: 20, max: 120 },
  /** WPM range (50 = very slow, 5000 = ultra-fast speed reading limit) */
  wpm: { min: 50, max: 5e3 },
  /** Acceleration duration in seconds (10 = quick ramp, 120 = gradual) */
  accelDuration: { min: 10, max: 120 },
  contextLines: { min: 0, max: 10 },
  contextFontSize: { min: 10, max: 32 }
};
var ICONS = {
  rewind: "lucide:skip-back",
  play: "lucide:play",
  pause: "lucide:pause",
  forward: "lucide:skip-forward",
  stop: "lucide:square",
  increment: "lucide:plus",
  decrement: "lucide:minus",
  settings: "lucide:settings",
  file: "lucide:file-text",
  celebration: "lucide:sparkles",
  book: "lucide:book-open",
  expand: "lucide:maximize-2"
};
var HEADING_MULTIPLIERS = {
  /** H1 heading multiplier (1.5x base font = major section) */
  h1: 1.5,
  /** H2 heading multiplier (1.3x base font) */
  h2: 1.3,
  /** H3 heading multiplier (1.2x base font) */
  h3: 1.2,
  /** H4 heading multiplier (1.1x base font) */
  h4: 1.1,
  /** H5 heading multiplier (1.05x base font) */
  h5: 1.05,
  /** H6 heading multiplier (1x base font = same as body text) */
  h6: 1
};

// src/dom-registry.ts
var DOMRegistry = class {
  constructor() {
    this.elements = /* @__PURE__ */ new Map();
  }
  /**
   * Register a DOM element by key
   *
   * Stores an element reference for later retrieval and updates. Should be
   * called once per element during UI construction.
   *
   * @param key - Type-safe key for the element (from DOMElementKey union)
   * @param element - HTMLElement to store
   *
   * @example
   * ```typescript
   * const wpmValue = controlGroup.createSpan({ cls: CSS_CLASSES.wpmValue });
   * this.dom.register('wpmValue', wpmValue);
   * ```
   */
  register(key, element) {
    this.elements.set(key, element);
  }
  /**
   * Get a registered DOM element
   *
   * Retrieves the stored element reference. Returns undefined if the key
   * was never registered.
   *
   * @param key - Key of the element to retrieve
   * @returns The HTMLElement if registered, undefined otherwise
   *
   * @example
   * ```typescript
   * const wpmEl = this.dom.get('wpmValue');
   * if (wpmEl) {
   *   // Do something with the element
   * }
   * ```
   */
  get(key) {
    return this.elements.get(key);
  }
  /**
   * Update text content of a registered element (XSS-safe)
   *
   * Uses Obsidian's setText() method which safely escapes HTML.
   * Preferred over updateHTML() for displaying user-generated content.
   *
   * @param key - Key of the element to update
   * @param text - Text content to set (string or number)
   *
   * @example
   * ```typescript
   * this.dom.updateText('wpmValue', 350);
   * this.dom.updateText('statsText', 'Words: 42 / 1000');
   * ```
   */
  updateText(key, text) {
    const element = this.elements.get(key);
    if (element) {
      element.setText(String(text));
    }
  }
  /**
   * @deprecated REMOVED for Obsidian security compliance.
   *
   * Using innerHTML with any content is discouraged by Obsidian plugin guidelines.
   * Instead, use DOM API methods to build HTML structures:
   * - element.createEl(), element.createSpan(), element.createDiv()
   * - element.setText() for text content (automatically escapes)
   * - element.empty() to clear contents
   *
   * See: https://docs.obsidian.md/Plugins/Releasing/Plugin+guidelines
   *
   * Migration example:
   * ```typescript
   * // OLD (unsafe):
   * this.dom.updateHTML('wordEl', `<span class="highlight">${word}</span>`);
   *
   * // NEW (safe):
   * const element = this.dom.get('wordEl');
   * element.empty();
   * element.createSpan({ text: word, cls: 'highlight' });
   * ```
   */
  /**
   * Update a CSS style property of a registered element
   *
   * Modifies inline styles. Useful for dynamic styling like font size,
   * colors, or positioning.
   *
   * @param key - Key of the element to update
   * @param property - CSS property name (camelCase, e.g., 'fontSize')
   * @param value - CSS value as string (e.g., '48px', '#ff0000')
   *
   * @example
   * ```typescript
   * this.dom.updateStyle('wordEl', 'fontSize', '48px');
   * this.dom.updateStyle('wordEl', 'color', '#ff0000');
   * this.dom.updateStyle('progressBar', 'width', '50%');
   * ```
   */
  updateStyle(key, property, value) {
    const element = this.elements.get(key);
    if (element) {
      element.style.setProperty(property, value);
    }
  }
  /**
   * Toggle CSS class on a registered element
   *
   * Conditionally adds or removes a CSS class. Commonly used for show/hide
   * functionality with CSS_CLASSES.hidden.
   *
   * @param key - Key of the element to update
   * @param className - CSS class name to toggle
   * @param force - True to add class, false to remove it
   *
   * @example
   * ```typescript
   * // Show controls (remove 'hidden' class)
   * this.dom.toggleClass('controlsEl', CSS_CLASSES.hidden, false);
   *
   * // Hide controls (add 'hidden' class)
   * this.dom.toggleClass('controlsEl', CSS_CLASSES.hidden, true);
   * ```
   */
  toggleClass(key, className, force) {
    const element = this.elements.get(key);
    if (element) {
      element.toggleClass(className, force);
    }
  }
  /**
   * Add CSS class to a registered element
   *
   * Adds a CSS class if not already present. Use for state changes like
   * highlighting, active states, etc.
   *
   * @param key - Key of the element to update
   * @param className - CSS class name to add
   *
   * @example
   * ```typescript
   * this.dom.addClass('playBtn', 'active');
   * this.dom.addClass('wordEl', CSS_CLASSES.highlight);
   * ```
   */
  addClass(key, className) {
    const element = this.elements.get(key);
    if (element) {
      element.classList.add(className);
    }
  }
  /**
   * Remove CSS class from a registered element
   *
   * Removes a CSS class if present. Use for removing state classes.
   *
   * @param key - Key of the element to update
   * @param className - CSS class name to remove
   *
   * @example
   * ```typescript
   * this.dom.removeClass('playBtn', 'active');
   * this.dom.removeClass('wordEl', CSS_CLASSES.highlight);
   * ```
   */
  removeClass(key, className) {
    const element = this.elements.get(key);
    if (element) {
      element.classList.remove(className);
    }
  }
  /**
   * Empty the content of a registered element
   *
   * Removes all child nodes and text content. Useful for clearing containers
   * before re-rendering.
   *
   * @param key - Key of the element to empty
   *
   * @example
   * ```typescript
   * // Clear the word display before loading new text
   * this.dom.empty('wordEl');
   * ```
   */
  empty(key) {
    const element = this.elements.get(key);
    if (element) {
      element.empty();
    }
  }
  /**
   * Check if an element is registered
   *
   * Returns true if an element with the given key has been registered.
   *
   * @param key - Key to check
   * @returns True if the key is registered, false otherwise
   *
   * @example
   * ```typescript
   * if (this.dom.has('statsEl')) {
   *   this.dom.updateText('statsEl', 'New stats');
   * }
   * ```
   */
  has(key) {
    return this.elements.has(key);
  }
  /**
   * Clear all registered elements
   *
   * Removes all element references from the registry. Typically used during
   * cleanup or when rebuilding the entire UI.
   *
   * @example
   * ```typescript
   * // During onunload
   * this.dom.clear();
   * ```
   */
  clear() {
    this.elements.clear();
  }
  /**
   * Update multiple text elements at once (batch update)
   *
   * Efficiently updates text content of multiple elements in a single call.
   * More readable than multiple individual updateText() calls.
   *
   * @param updates - Object mapping element keys to new text values
   *
   * @example
   * ```typescript
   * // Update all WPM displays at once
   * this.dom.updateMultipleText({
   *   wpmDisplay: `${wpm} WPM`,
   *   wpmValue: String(wpm),
   *   wpmInlineValue: String(wpm)
   * });
   *
   * // Update stats panel
   * this.dom.updateMultipleText({
   *   statsText: `Words: ${wordsRead} / ${totalWords}`,
   *   progressBar: `${percent}%`
   * });
   * ```
   */
  updateMultipleText(updates) {
    Object.entries(updates).forEach(([key, value]) => {
      if (value !== void 0) {
        this.updateText(key, value);
      }
    });
  }
  /**
   * Toggle visibility of multiple elements (batch visibility)
   *
   * Efficiently shows or hides multiple elements using CSS_CLASSES.hidden.
   * More readable than multiple individual toggleClass() calls.
   *
   * @param toggles - Object mapping element keys to visibility booleans (true = visible, false = hidden)
   *
   * @example
   * ```typescript
   * // Show play button, hide pause button
   * this.dom.toggleMultipleVisibility({
   *   playBtn: true,
   *   pauseBtn: false
   * });
   *
   * // Hide all panels
   * this.dom.toggleMultipleVisibility({
   *   controlsEl: false,
   *   settingsEl: false,
   *   statsEl: false
   * });
   * ```
   */
  toggleMultipleVisibility(toggles) {
    Object.entries(toggles).forEach(([key, visible]) => {
      if (typeof visible === "boolean") {
        this.toggleClass(key, CSS_CLASSES.hidden, !visible);
      }
    });
  }
};

// src/breadcrumb-manager.ts
var import_obsidian = require("obsidian");

// src/menu-builder.ts
var MenuBuilder = class {
  /**
   * Creates a dropdown menu near an anchor element
   *
   * @param options - Menu configuration
   * @returns The created menu element
   */
  static createMenu(options) {
    const {
      anchorEl,
      cssClass,
      title,
      items,
      onItemClick,
      showLevel = false,
      indentByLevel = false,
      timeoutManager
    } = options;
    const menu = document.body.createDiv({ cls: cssClass });
    menu.style.visibility = "hidden";
    try {
      menu.style.fontFamily = getComputedStyle(anchorEl).fontFamily;
    } catch (e) {
    }
    let closed = false;
    const cleanup = (reason) => {
      var _a;
      if (closed)
        return;
      closed = true;
      menu.remove();
      document.removeEventListener("pointerdown", closeMenuOnPointerDown, true);
      (_a = options.onClose) == null ? void 0 : _a.call(options, reason);
    };
    if (title) {
      menu.createDiv({
        text: title,
        cls: "dashreader-menu-title"
      });
    }
    items.forEach((item, index) => {
      const menuItem = menu.createDiv({
        cls: item.isCurrent ? "dashreader-menu-item dashreader-menu-item-current" : "dashreader-menu-item"
      });
      if (indentByLevel && item.level) {
        const indent = (item.level - 1) * 16;
        menuItem.style.paddingLeft = item.isCurrent ? `${8 + indent - 3}px` : `${8 + indent}px`;
      }
      if (showLevel && item.level) {
        menuItem.createSpan({
          text: `H${item.level}`,
          cls: "dashreader-outline-level"
        });
      } else if (!showLevel) {
        menuItem.createSpan({
          text: `${index + 1}.`,
          cls: "dashreader-outline-level"
        });
      }
      menuItem.createSpan({
        text: item.text,
        cls: "dashreader-outline-text"
      });
      menuItem.addEventListener("click", () => {
        onItemClick(item.wordIndex);
        cleanup("select");
      });
    });
    const positionMenu = () => {
      const anchorRect = anchorEl.getBoundingClientRect();
      const isMobile = window.matchMedia("(max-width: 768px)").matches;
      const isOutlineMenu = cssClass.includes("dashreader-outline-menu");
      const isHeadingMenu = cssClass.includes("heading-menu");
      let top = anchorRect.bottom + 5;
      let left = anchorRect.left;
      if (isHeadingMenu) {
        const menuWidth = 300;
        const centerLeft = anchorRect.left + (anchorRect.width - menuWidth) / 2;
        const viewportWidth = window.innerWidth;
        const finalLeft = Math.max(10, Math.min(centerLeft, viewportWidth - menuWidth - 10));
        left = finalLeft;
      }
      if (isMobile && isOutlineMenu) {
        const menuRect = menu.getBoundingClientRect();
        const viewportW = window.innerWidth;
        const viewportH = window.innerHeight;
        const margin = 10;
        left = anchorRect.left + (anchorRect.width - menuRect.width) / 2;
        left = Math.max(margin, Math.min(left, viewportW - menuRect.width - margin));
        const belowTop = anchorRect.bottom + 5;
        const aboveTop = anchorRect.top - menuRect.height - 5;
        top = belowTop;
        if (belowTop + menuRect.height > viewportH - margin) {
          if (aboveTop >= margin) {
            top = aboveTop;
          } else {
            top = Math.max(margin, viewportH - menuRect.height - margin);
          }
        }
      }
      menu.style.left = `${left}px`;
      menu.style.top = `${top}px`;
      menu.style.visibility = "";
    };
    requestAnimationFrame(positionMenu);
    const closeMenuOnPointerDown = (e) => {
      var _a;
      const target = e.target;
      if (!target)
        return;
      if (menu.contains(target))
        return;
      e.preventDefault();
      e.stopPropagation();
      (_a = e.stopImmediatePropagation) == null ? void 0 : _a.call(e);
      cleanup("dismiss");
    };
    timeoutManager.setTimeout(() => {
      document.addEventListener("pointerdown", closeMenuOnPointerDown, true);
    }, 10);
    return {
      el: menu,
      close: (reason = "dismiss") => cleanup(reason),
      isOpen: () => !closed
    };
  }
  /**
   * Scrolls to the current item in the menu (for outline menu)
   *
   * @param menu - The menu element
   * @param timeoutManager - Timeout manager for proper cleanup
   */
  static scrollToCurrentItem(menu, timeoutManager) {
    timeoutManager.setTimeout(() => {
      const currentItem = menu.querySelector(".dashreader-menu-item-current");
      if (currentItem) {
        currentItem.scrollIntoView({ block: "center" });
      }
    }, 10);
  }
};

// src/breadcrumb-manager.ts
var BreadcrumbManager = class {
  constructor(breadcrumbEl, engine, timeoutManager, opts = {}) {
    this.lastHeadingContext = null;
    this.activeOutlineMenu = null;
    /**
     * Callout icon mapping (consistent with WordDisplay)
     */
    this.calloutIcons = {
      note: "\u{1F4DD}",
      abstract: "\u{1F4C4}",
      info: "\u2139\uFE0F",
      tip: "\u{1F4A1}",
      success: "\u2705",
      question: "\u2753",
      warning: "\u26A0\uFE0F",
      failure: "\u274C",
      danger: "\u26A1",
      bug: "\u{1F41B}",
      example: "\u{1F4CB}",
      quote: "\u{1F4AC}"
    };
    this.breadcrumbEl = breadcrumbEl;
    this.engine = engine;
    this.timeoutManager = timeoutManager;
    this.onPlayStateChange = opts.onPlayStateChange;
    this.canAutoResume = opts.canAutoResume;
  }
  /**
   * Updates the breadcrumb navigation bar with current heading context
   * Shows hierarchical path (H1 > H2 > H3) and makes it clickable for navigation
   *
   * @param context - Current heading context from engine
   */
  updateBreadcrumb(context) {
    const hasAnyHeadings = this.engine.getHeadings().length > 0;
    if (!hasAnyHeadings) {
      this.breadcrumbEl.toggleClass(CSS_CLASSES.hidden, true);
      return;
    }
    this.breadcrumbEl.toggleClass(CSS_CLASSES.hidden, false);
    this.breadcrumbEl.empty();
    const docIcon = this.breadcrumbEl.createSpan({ cls: "dashreader-breadcrumb-icon" });
    (0, import_obsidian.setIcon)(docIcon, "file-text");
    docIcon.addEventListener("click", () => this.showOutlineMenu(docIcon));
    const pathEl = this.breadcrumbEl.createSpan({ cls: "dashreader-breadcrumb-path" });
    if (!context || context.breadcrumb.length === 0) {
      pathEl.createSpan({
        text: "Top",
        cls: "dashreader-breadcrumb-item dashreader-breadcrumb-item--last"
      });
    } else {
      const lastIdx = context.breadcrumb.length - 1;
      context.breadcrumb.forEach((heading, index) => {
        if (index > 0) {
          pathEl.createSpan({ text: "\u203A", cls: "dashreader-breadcrumb-separator" });
        }
        const itemSpan = pathEl.createSpan({
          cls: `dashreader-breadcrumb-item ${index === lastIdx ? "dashreader-breadcrumb-item--last" : ""}`.trim()
        });
        const displayText = heading.text.replace(/^\[CALLOUT:[\w-]+\]/, "").trim();
        itemSpan.textContent = displayText;
        itemSpan.addEventListener("click", () => this.navigateToHeading(heading.wordIndex));
      });
    }
    const dropdown = this.breadcrumbEl.createSpan({ cls: "dashreader-breadcrumb-dropdown" });
    (0, import_obsidian.setIcon)(dropdown, "chevron-down");
    dropdown.addEventListener("click", () => this.showOutlineMenu(dropdown));
    this.lastHeadingContext = context;
  }
  /**
   * Closes all open menus (outline menus)
   * Called before opening a new menu to ensure only one menu is visible
   */
  closeAllMenus() {
    var _a;
    if ((_a = this.activeOutlineMenu) == null ? void 0 : _a.isOpen()) {
      this.activeOutlineMenu.close("dismiss");
    }
    this.activeOutlineMenu = null;
    document.querySelectorAll(".dashreader-outline-menu").forEach((menu) => menu.remove());
  }
  /**
   * Checks if heading context has changed (to avoid unnecessary updates)
   *
   * @param newContext - New heading context to check
   * @returns True if context has changed, false otherwise
   */
  hasHeadingContextChanged(newContext) {
    if (!this.lastHeadingContext)
      return true;
    if (this.lastHeadingContext.breadcrumb.length !== newContext.breadcrumb.length) {
      return true;
    }
    for (let i = 0; i < newContext.breadcrumb.length; i++) {
      if (this.lastHeadingContext.breadcrumb[i].wordIndex !== newContext.breadcrumb[i].wordIndex) {
        return true;
      }
    }
    return false;
  }
  /**
   * Shows outline menu with all headings in the document
   * Displays complete document structure with indentation by level
   * Highlights current position in the list
   *
   * @param anchorEl - The element to position the menu relative to
   */
  showOutlineMenu(anchorEl) {
    var _a, _b;
    if ((_a = this.activeOutlineMenu) == null ? void 0 : _a.isOpen()) {
      this.activeOutlineMenu.close("dismiss");
      this.activeOutlineMenu = null;
      return;
    }
    this.closeAllMenus();
    const allHeadings = this.engine.getHeadings();
    if (allHeadings.length === 0) {
      return;
    }
    const wasPlayingBeforeMenu = this.engine.getIsPlaying();
    if (wasPlayingBeforeMenu) {
      this.engine.pause();
      (_b = this.onPlayStateChange) == null ? void 0 : _b.call(this, false);
    }
    let didSelect = false;
    const currentIndex = this.engine.getCurrentIndex();
    const relevantHeadings = allHeadings.filter((h) => h.wordIndex <= currentIndex);
    const currentHeading = relevantHeadings.length > 0 ? relevantHeadings[relevantHeadings.length - 1] : null;
    const menu = MenuBuilder.createMenu({
      anchorEl,
      cssClass: "dashreader-outline-menu",
      title: "Document Outline",
      items: allHeadings.map((h) => ({
        text: h.text,
        wordIndex: h.wordIndex,
        level: h.level,
        isCurrent: currentHeading ? h.wordIndex === currentHeading.wordIndex : false
      })),
      onItemClick: (wordIndex) => {
        didSelect = true;
        this.navigateToHeading(wordIndex);
      },
      showLevel: true,
      indentByLevel: true,
      timeoutManager: this.timeoutManager,
      onClose: (reason) => {
        var _a2, _b2, _c;
        this.activeOutlineMenu = null;
        const canResume = this.canAutoResume ? this.canAutoResume() : true;
        if (!canResume)
          return;
        if (reason === "dismiss") {
          if (wasPlayingBeforeMenu) {
            this.engine.play();
            (_a2 = this.onPlayStateChange) == null ? void 0 : _a2.call(this, true);
          }
          return;
        }
        if (reason === "select" && didSelect) {
          if (wasPlayingBeforeMenu) {
            this.engine.play();
            (_b2 = this.onPlayStateChange) == null ? void 0 : _b2.call(this, true);
          } else {
            (_c = this.onPlayStateChange) == null ? void 0 : _c.call(this, false);
          }
        }
      }
    });
    this.activeOutlineMenu = menu;
    MenuBuilder.scrollToCurrentItem(menu.el, this.timeoutManager);
  }
  /**
   * Navigates to a specific heading by word index
   * Pauses playback, jumps to the heading position, and resumes if it was playing
   *
   * @param wordIndex - Word index to navigate to
   */
  navigateToHeading(wordIndex) {
    var _a;
    this.engine.jumpToIndex(wordIndex);
    (_a = this.onPlayStateChange) == null ? void 0 : _a.call(this, this.engine.getIsPlaying());
  }
  /**
   * Resets the breadcrumb state (for new text loading)
   */
  reset() {
    this.lastHeadingContext = null;
  }
};

// src/word-display.ts
var import_obsidian2 = require("obsidian");
var WordDisplay = class {
  constructor(wordEl, settings, baseFontSizePx, baseChunkSize) {
    /**
     * Callout icon mapping
     */
    this.calloutIcons = {
      note: "\u{1F4DD}",
      abstract: "\u{1F4C4}",
      info: "\u2139\uFE0F",
      tip: "\u{1F4A1}",
      success: "\u2705",
      question: "\u2753",
      warning: "\u26A0\uFE0F",
      failure: "\u274C",
      danger: "\u26A1",
      bug: "\u{1F41B}",
      example: "\u{1F4CB}",
      quote: "\u{1F4AC}"
    };
    this.wordEl = wordEl;
    this.settings = settings;
    this.wordEl.empty();
    this.wordEl.style.position = "relative";
    this.wordEl.setAttribute("data-running", "false");
    this.baseFontSizePx = baseFontSizePx;
    this.baseChunkSize = Math.max(1, baseChunkSize);
    this.overlayEl = this.wordEl.createDiv({ cls: "dashreader-focus-overlay" });
    this.overlayEl.createDiv({ cls: "dashreader-focus-lines" });
    this.focusDashesEl = this.overlayEl.createDiv({ cls: "dashreader-focus-dashes" });
    this.contentEl = this.wordEl.createDiv({ cls: "dashreader-word-content" });
    this.wordEl.style.setProperty("--dashreader-focus-left", "48%");
  }
  setBaseFontSize(px) {
    this.baseFontSizePx = px;
  }
  setChunkSize(n) {
    this.baseChunkSize = Math.max(1, n);
  }
  /**
   * Updates settings (when user changes font size, etc.)
   *
   * @param settings - New settings to apply
   */
  updateSettings(settings) {
    this.settings = settings;
  }
  /**
   * Displays a word with optional heading level or callout type
   * Handles font size adjustment, icons, and separators
   *
   * @param word - The word to display
   * @param headingLevel - Heading level (1-6) or 0 for normal text/callouts
   * @param showSeparator - Whether to show separator line before heading/callout
   * @param calloutType - Callout type (note, abstract, info, etc.) if this is a callout
   */
  displayWord(word, headingLevel, showSeparator = false, calloutType) {
    let fontSizeMultiplier = 1;
    let fontWeight = "normal";
    let iconPrefix = "";
    if (calloutType) {
      fontSizeMultiplier = 1.2;
      fontWeight = "bold";
      iconPrefix = this.calloutIcons[calloutType.toLowerCase()] || "\u{1F4CC}";
    } else if (headingLevel > 0) {
      const multipliers = [
        0,
        HEADING_MULTIPLIERS.h1,
        HEADING_MULTIPLIERS.h2,
        HEADING_MULTIPLIERS.h3,
        HEADING_MULTIPLIERS.h4,
        HEADING_MULTIPLIERS.h5,
        HEADING_MULTIPLIERS.h6
      ];
      fontSizeMultiplier = multipliers[headingLevel] || 1;
      fontWeight = "bold";
    }
    const adjustedFontSize = this.baseFontSizePx * fontSizeMultiplier;
    const cleanedTrimmed = this.stripMarkers(word).trim();
    const isPhrase = /\s/.test(cleanedTrimmed);
    const cleaned = this.stripMarkers(word).trim();
    const displayText = cleaned.length ? cleaned : word.trim();
    const chunkSize = Math.max(1, this.baseChunkSize || 1);
    const center = 48;
    const left = 15;
    const maxChunkForFullShift = 5;
    const t = Math.min(1, Math.max(0, (chunkSize - 1) / (maxChunkForFullShift - 1)));
    const focus = center - t * (center - left);
    this.wordEl.style.setProperty("--dashreader-focus-left", `${focus}%`);
    this.wordEl.setAttribute("data-running", "true");
    this.wordEl.querySelectorAll(".dashreader-welcome-message, .dashreader-ready-message").forEach((el) => el.remove());
    this.contentEl.empty();
    if (showSeparator) {
      this.contentEl.createDiv({ cls: "dashreader-heading-separator" });
    }
    const wordContainer = this.contentEl.createDiv({ cls: "dashreader-word-with-heading" });
    wordContainer.style.fontSize = `${adjustedFontSize}px`;
    wordContainer.style.fontWeight = fontWeight;
    if (iconPrefix) {
      wordContainer.createSpan({
        text: iconPrefix,
        cls: "dashreader-callout-icon"
      });
    }
    const viewport = wordContainer.createDiv({ cls: "dashreader-orp-viewport" });
    const line = viewport.createDiv({ cls: "dashreader-orp-line" });
    const chunkMode = (this.baseChunkSize || 1) > 1;
    const orpEl = chunkMode && /\s/.test(cleaned) ? this.buildChunkSpans(line, cleaned) : this.buildWordSpans(line, cleaned);
    const focusWordEl = line.querySelector(".dashreader-focus-word");
    const shouldShrink = cleanedTrimmed !== "\n";
    requestAnimationFrame(() => {
      wordContainer.style.fontSize = `${adjustedFontSize}px`;
      if (viewport.clientWidth === 0) {
        requestAnimationFrame(() => {
          wordContainer.style.fontSize = `${adjustedFontSize}px`;
          if (shouldShrink) {
            const minSize = Math.max(8, this.settings.minTokenFontSize || 12);
            this.shrinkFocusWordToFit(viewport, line, focusWordEl, orpEl, adjustedFontSize, minSize);
          }
          this.applyOrpAnchoring(viewport, line, orpEl);
        });
        return;
      }
      if (shouldShrink) {
        const minSize = Math.max(8, this.settings.minTokenFontSize || 12);
        this.shrinkFocusWordToFit(viewport, line, focusWordEl, orpEl, adjustedFontSize, minSize);
      }
      this.applyOrpAnchoring(viewport, line, orpEl);
    });
  }
  stripMarkers(rawWord) {
    return rawWord.replace(/^\[H\d\]/, "").replace(/^\[CALLOUT:[\w-]+\]/, "");
  }
  renderIcon(into, icon) {
    if (icon.startsWith("lucide:"))
      (0, import_obsidian2.setIcon)(into, icon.slice("lucide:".length));
    else
      into.setText(icon);
  }
  /**
   * Squirt-style ORP index (punctuation-aware).
   * Matches squirtSquirt.js getORPIndex logic.
   */
  getORPIndex(word) {
    const str = word.endsWith("\n") ? word.slice(0, -1) : word;
    const len = str.length;
    if (len <= 0)
      return 0;
    let point = 4;
    if (len < 2)
      point = 0;
    else if (len < 6)
      point = 1;
    else if (len < 10)
      point = 2;
    else if (len < 14)
      point = 3;
    const isLetterOrDigit = (ch) => !!ch && (/\d/.test(ch) || ch.toLowerCase() !== ch.toUpperCase());
    if (!isLetterOrDigit(str[point])) {
      if (isLetterOrDigit(str[point - 1]))
        point--;
      else if (isLetterOrDigit(str[point + 1]))
        point++;
    }
    if (point < 0)
      point = 0;
    if (point >= str.length)
      point = str.length - 1;
    return point;
  }
  /**
   * Builds spans for the word into `lineEl` and returns the ORP span.
   */
  buildWordSpans(lineEl, displayWord) {
    lineEl.empty();
    if (!displayWord || displayWord === "\n")
      return null;
    const focusWordEl = lineEl.createSpan({ cls: "dashreader-focus-word" });
    const orpIndex = this.getORPIndex(displayWord);
    for (let i = 0; i < displayWord.length; i++) {
      const ch = displayWord.charAt(i);
      const span = focusWordEl.createSpan({ text: ch });
      if (i === orpIndex) {
        span.addClass("dashreader-highlight");
        span.addClass("dashreader-orp");
      }
    }
    return focusWordEl.querySelector(".dashreader-orp");
  }
  buildChunkSpans(lineEl, chunkText) {
    lineEl.empty();
    if (!chunkText || chunkText === "\n")
      return null;
    const parts = chunkText.split(/\s+/).filter(Boolean);
    if (parts.length === 0)
      return null;
    const main = parts[0];
    const sequel = parts.slice(1).join(" ");
    const focusWordEl = lineEl.createSpan({ cls: "dashreader-focus-word" });
    const orpIndex = this.getORPIndex(main);
    for (let i = 0; i < main.length; i++) {
      const ch = main.charAt(i);
      const span = focusWordEl.createSpan({ text: ch });
      if (i === orpIndex) {
        span.addClass("dashreader-highlight");
        span.addClass("dashreader-orp");
      }
    }
    if (sequel.length) {
      lineEl.appendChild(document.createTextNode("\xA0"));
      lineEl.createSpan({ text: sequel, cls: "dashreader-inline-context" });
    }
    return lineEl.querySelector(".dashreader-orp");
  }
  /**
   * Applies ORP anchoring by measuring the ORP span and shifting the whole line.
   * Anchor is the horizontal centre of the viewport.
   */
  applyOrpAnchoring(viewportEl, lineEl, orpEl) {
    if (!orpEl) {
      lineEl.style.transform = "translateX(0px)";
      return;
    }
    lineEl.style.transform = "translateX(0px)";
    const viewportRect = viewportEl.getBoundingClientRect();
    const focusRect = this.focusDashesEl.getBoundingClientRect();
    const focusX = focusRect.left + focusRect.width / 2 - viewportRect.left;
    const lineLeft = lineEl.offsetLeft;
    const orpCenterInLine = orpEl.offsetLeft + orpEl.offsetWidth / 2;
    const delta = focusX - (lineLeft + orpCenterInLine);
    lineEl.style.transform = `translateX(${Math.round(delta)}px)`;
  }
  /**
   * Binary-search shrink for a single token if it overflows the viewport.
   * Returns the font size actually applied.
   */
  shrinkFocusWordToFit(viewportEl, lineEl, focusWordEl, orpEl, startSize, minSize) {
    if (!focusWordEl || !orpEl)
      return startSize;
    const prevTransition = focusWordEl.style.transition;
    focusWordEl.style.transition = "none";
    const fitsFocusWord = () => {
      const viewportW = viewportEl.clientWidth;
      if (viewportW <= 0)
        return true;
      const viewportRect = viewportEl.getBoundingClientRect();
      const focusRect = this.focusDashesEl.getBoundingClientRect();
      const focusX = focusRect.left + focusRect.width / 2 - viewportRect.left;
      const orpCenter = orpEl.offsetLeft + orpEl.offsetWidth / 2;
      const wordLeft = focusWordEl.offsetLeft;
      const wordRight = wordLeft + focusWordEl.offsetWidth;
      const leftDist = orpCenter - wordLeft;
      const rightDist = wordRight - orpCenter;
      const leftEdge = focusX - leftDist;
      const rightEdge = focusX + rightDist;
      return leftEdge >= 0 && rightEdge <= viewportW;
    };
    focusWordEl.style.fontSize = `${startSize}px`;
    lineEl.getBoundingClientRect();
    if (fitsFocusWord()) {
      focusWordEl.style.transition = prevTransition;
      return startSize;
    }
    let lo = Math.max(8, minSize);
    let hi = startSize;
    let best = lo;
    while (lo <= hi) {
      const mid = Math.floor((lo + hi) / 2);
      focusWordEl.style.fontSize = `${mid}px`;
      lineEl.getBoundingClientRect();
      if (fitsFocusWord()) {
        best = mid;
        lo = mid + 1;
      } else {
        hi = mid - 1;
      }
    }
    focusWordEl.style.fontSize = `${best}px`;
    lineEl.getBoundingClientRect();
    focusWordEl.style.transition = prevTransition;
    return best;
  }
  /**
   * Adds a processed word to the container using DOM API
   * This prevents XSS attacks by never using innerHTML with user content
   *
   * @param container - Container element to add word to
   * @param rawWord - Raw word (may contain special characters)
   */
  addProcessedWord(container, rawWord) {
    if (rawWord === "\n") {
      container.createEl("br");
      return;
    }
    const word = rawWord.replace(/^\[H\d\]/, "").replace(/^\[CALLOUT:[\w-]+\]/, "");
    if (word.length > 0) {
      const centerIndex = Math.floor(word.length / 3);
      const before = word.substring(0, centerIndex);
      const center = word.charAt(centerIndex);
      const after = word.substring(centerIndex + 1);
      if (before) {
        container.createSpan({ text: before });
      }
      container.createSpan({
        text: center,
        cls: "dashreader-highlight"
      });
      if (after) {
        container.createSpan({ text: after });
      }
    } else {
      container.setText(word);
    }
  }
  /**
   * Displays a welcome message (no text loaded)
   * Uses DOM API to build the message instead of innerHTML
   *
   * @param icon - Icon to display
   * @param mainText - Main message text
   * @param subText - Instruction text
   */
  displayWelcomeMessage(icon, mainText, subText) {
    this.contentEl.empty();
    this.wordEl.setAttribute("data-running", "false");
    const welcomeDiv = this.contentEl.createDiv({ cls: "dashreader-welcome-message" });
    welcomeDiv.createDiv({
      text: `${icon} ${mainText}`,
      cls: "dashreader-welcome-icon"
    });
    welcomeDiv.createDiv({
      text: subText,
      cls: "dashreader-welcome-instruction"
    });
  }
  /**
   * Displays a ready message (text loaded, ready to start)
   * Uses DOM API to build the message instead of innerHTML
   *
   * @param wordsToRead - Number of words to read
   * @param totalWords - Total words in document
   * @param startIndex - Starting word index (if resuming)
   * @param durationText - Formatted estimated duration
   * @param fileName - Optional source file name
   * @param lineNumber - Optional source line number
   */
  displayReadyMessage(wordsToRead, totalWords, startIndex, durationText, fileName, lineNumber) {
    this.contentEl.empty();
    this.wordEl.setAttribute("data-running", "false");
    const readyDiv = this.contentEl.createDiv({ cls: "dashreader-ready-message" });
    if (fileName) {
      const sourceDiv = readyDiv.createDiv({ cls: "dashreader-ready-source" });
      const iconSpan = sourceDiv.createSpan({ cls: "dashreader-inline-icon" });
      (0, import_obsidian2.setIcon)(
        iconSpan,
        ICONS.file.startsWith("lucide:") ? ICONS.file.slice("lucide:".length) : ICONS.file
      );
      sourceDiv.createSpan({ text: " " });
      sourceDiv.createSpan({ text: fileName });
      if (lineNumber) {
        sourceDiv.createSpan({ text: ` (line ${lineNumber})` });
      }
    }
    const mainText = readyDiv.createSpan();
    mainText.createSpan({ text: `Ready to read ${wordsToRead} words` });
    if (startIndex !== void 0 && startIndex > 0) {
      const startInfo = mainText.createSpan({ cls: "dashreader-ready-start-info" });
      startInfo.setText(` (starting at word ${startIndex + 1}/${totalWords})`);
    }
    readyDiv.createEl("br");
    readyDiv.createSpan({
      text: `Estimated time: ~${durationText}`,
      cls: "dashreader-ready-duration"
    });
    readyDiv.createEl("br");
    readyDiv.createSpan({
      text: "Press Space to start",
      cls: "dashreader-ready-duration"
    });
  }
  /**
   * Clears the word display
   */
  clear() {
    this.contentEl.empty();
    this.wordEl.setAttribute("data-running", "false");
  }
};

// src/hotkey-handler.ts
var HotkeyHandler = class {
  constructor(settings, callbacks) {
    this.settings = settings;
    this.callbacks = callbacks;
  }
  /**
   * Updates settings (when user changes hotkey preferences)
   *
   * @param settings - New settings to apply
   */
  updateSettings(settings) {
    this.settings = settings;
  }
  /**
   * Handles keyboard events
   * Called from keydown event listener in the view
   *
   * @param e - Keyboard event
   */
  handleKeyPress(e) {
    const keyCode = e.code || e.key;
    if (keyCode === this.settings.hotkeyPlay) {
      if (this.isInputFocused())
        return;
      e.preventDefault();
      this.callbacks.onTogglePlay();
      return;
    }
    if (this.isInputFocused()) {
      return;
    }
    if (keyCode === this.settings.hotkeyRewind) {
      e.preventDefault();
      this.callbacks.onRewind();
      return;
    }
    if (keyCode === this.settings.hotkeyForward) {
      e.preventDefault();
      this.callbacks.onForward();
      return;
    }
    if (keyCode === this.settings.hotkeyIncrementWpm) {
      e.preventDefault();
      this.callbacks.onIncrementWpm();
      return;
    }
    if (keyCode === this.settings.hotkeyDecrementWpm) {
      e.preventDefault();
      this.callbacks.onDecrementWpm();
      return;
    }
    if (keyCode === this.settings.hotkeyQuit) {
      e.preventDefault();
      this.callbacks.onQuit();
      return;
    }
  }
  /**
   * Checks if an input element is currently focused
   * Prevents hotkeys from interfering with typing
   *
   * @returns True if input/textarea is focused
   */
  isInputFocused() {
    const activeElement = document.activeElement;
    if (!activeElement)
      return false;
    const tagName = activeElement.tagName.toLowerCase();
    return tagName === "input" || tagName === "textarea";
  }
};

// src/services/timeout-manager.ts
var TimeoutManager = class {
  constructor() {
    this.timeouts = /* @__PURE__ */ new Map();
    this.intervals = /* @__PURE__ */ new Map();
  }
  /**
   * Create a timeout that will be automatically tracked
   *
   * @param callback - Function to execute after delay
   * @param delay - Delay in milliseconds
   * @returns Timeout ID (can be used with clearTimeout)
   *
   * @example
   * ```typescript
   * const id = this.timeoutManager.setTimeout(() => {
   *   console.log('Hello!');
   * }, 1000);
   * ```
   */
  setTimeout(callback, delay) {
    const id = window.setTimeout(() => {
      callback();
      this.timeouts.delete(id);
    }, delay);
    this.timeouts.set(id, id);
    return id;
  }
  /**
   * Create an interval that will be automatically tracked
   *
   * @param callback - Function to execute repeatedly
   * @param delay - Delay between executions in milliseconds
   * @returns Interval ID (can be used with clearInterval)
   *
   * @example
   * ```typescript
   * const id = this.timeoutManager.setInterval(() => {
   *   console.log('Tick');
   * }, 1000);
   * ```
   */
  setInterval(callback, delay) {
    const id = window.setInterval(callback, delay);
    this.intervals.set(id, id);
    return id;
  }
  /**
   * Clear a specific timeout
   *
   * @param id - Timeout ID returned by setTimeout
   *
   * @example
   * ```typescript
   * const id = this.timeoutManager.setTimeout(...);
   * this.timeoutManager.clearTimeout(id); // Cancel it
   * ```
   */
  clearTimeout(id) {
    window.clearTimeout(id);
    this.timeouts.delete(id);
  }
  /**
   * Clear a specific interval
   *
   * @param id - Interval ID returned by setInterval
   *
   * @example
   * ```typescript
   * const id = this.timeoutManager.setInterval(...);
   * this.timeoutManager.clearInterval(id); // Stop it
   * ```
   */
  clearInterval(id) {
    window.clearInterval(id);
    this.intervals.delete(id);
  }
  /**
   * Clear all pending timeouts and intervals
   *
   * IMPORTANT: Call this in your component's destroy/cleanup method
   * to prevent memory leaks.
   *
   * @example
   * ```typescript
   * destroy() {
   *   this.timeoutManager.clearAll();
   * }
   * ```
   */
  clearAll() {
    this.timeouts.forEach((id) => window.clearTimeout(id));
    this.timeouts.clear();
    this.intervals.forEach((id) => window.clearInterval(id));
    this.intervals.clear();
  }
  /**
   * Get the number of active timers (for debugging/testing)
   *
   * @returns Number of active timeouts + intervals
   *
   * @example
   * ```typescript
   * console.log(`Active timers: ${this.timeoutManager.activeCount}`);
   * ```
   */
  get activeCount() {
    return this.timeouts.size + this.intervals.size;
  }
  /**
   * Get the number of active timeouts only (for debugging/testing)
   */
  get activeTimeouts() {
    return this.timeouts.size;
  }
  /**
   * Get the number of active intervals only (for debugging/testing)
   */
  get activeIntervals() {
    return this.intervals.size;
  }
};

// src/ui-builders.ts
var import_obsidian3 = require("obsidian");
function createButton(parent, config) {
  var _a;
  const className = config.className || CSS_CLASSES.btn;
  const btn = parent.createEl("button", {
    cls: className,
    attr: {
      "aria-label": config.title,
      type: "button"
    }
  });
  if ((_a = config.icon) == null ? void 0 : _a.startsWith("lucide:")) {
    (0, import_obsidian3.setIcon)(btn, config.icon.slice("lucide:".length));
  } else if (config.icon) {
    btn.setText(config.icon);
  }
  btn.addEventListener("click", config.onClick);
  return btn;
}
function createNumberControl(parent, config, registry) {
  const container = parent.createDiv({ cls: CSS_CLASSES.controlGroup });
  container.createEl("span", {
    text: config.label,
    cls: CSS_CLASSES.controlLabel
  });
  createButton(container, {
    icon: config.decrementIcon || ICONS.decrement,
    title: config.decrementTitle || `Decrease (-${config.increment || 1})`,
    onClick: config.onDecrement,
    className: CSS_CLASSES.smallBtn
  });
  const valueEl = container.createEl("span", {
    text: String(config.value),
    cls: config.registryKey || "value-display"
  });
  if (config.registryKey && registry) {
    registry.register(config.registryKey, valueEl);
  }
  createButton(container, {
    icon: config.incrementIcon || ICONS.increment,
    title: config.incrementTitle || `Increase (+${config.increment || 1})`,
    onClick: config.onIncrement,
    className: CSS_CLASSES.smallBtn
  });
  return { container, valueEl };
}
function createToggleControl(parent, config) {
  const container = parent.createDiv({ cls: CSS_CLASSES.settingGroup });
  const toggle = container.createEl("label", { cls: CSS_CLASSES.settingToggle });
  const checkbox = toggle.createEl("input", { type: "checkbox" });
  checkbox.checked = config.checked;
  checkbox.addEventListener("change", () => {
    config.onChange(checkbox.checked);
  });
  toggle.createEl("span", { text: ` ${config.label}` });
  return { container, checkbox };
}
function createPlayPauseButtons(parent, onPlay, onPause, registry) {
  const playBtn = createButton(parent, {
    icon: ICONS.play,
    title: "Play (Space)",
    onClick: onPlay,
    className: `${CSS_CLASSES.toggleBtn} ${CSS_CLASSES.playBtn}`
  });
  const pauseBtn = createButton(parent, {
    icon: ICONS.pause,
    title: "Pause (Space)",
    onClick: onPause,
    className: `${CSS_CLASSES.toggleBtn} ${CSS_CLASSES.pauseBtn} ${CSS_CLASSES.hidden}`
  });
  registry.register("playBtn", playBtn);
  registry.register("pauseBtn", pauseBtn);
}
function updatePlayPauseButtons(registry, isPlaying) {
  registry.toggleClass("playBtn", CSS_CLASSES.hidden, isPlaying);
  registry.toggleClass("pauseBtn", CSS_CLASSES.hidden, !isPlaying);
}

// src/auto-load-manager.ts
var import_obsidian4 = require("obsidian");
function isNavigationKey(evt) {
  return (
    // Arrow keys
    evt.key === "ArrowUp" || evt.key === "ArrowDown" || evt.key === "ArrowLeft" || evt.key === "ArrowRight" || // Home/End/PageUp/PageDown
    evt.key === "Home" || evt.key === "End" || evt.key === "PageUp" || evt.key === "PageDown" || // Enter
    evt.key === "Enter" || // Vim-style navigation
    evt.key === "j" && evt.ctrlKey || evt.key === "k" && evt.ctrlKey || evt.key === "d" && evt.ctrlKey || evt.key === "u" && evt.ctrlKey || // Cmd/Ctrl + arrows
    (evt.key === "ArrowUp" || evt.key === "ArrowDown") && (evt.metaKey || evt.ctrlKey)
  );
}
function isSelectionKey(evt) {
  return evt.shiftKey || evt.key === "a" && (evt.metaKey || evt.ctrlKey);
}
function extractEditorContent(app) {
  const activeView = app.workspace.getActiveViewOfType(import_obsidian4.MarkdownView);
  if (!activeView) {
    return { activeView: null, currentFile: null };
  }
  const currentFile = app.workspace.getActiveFile();
  if (!currentFile) {
    return { activeView, currentFile: null };
  }
  const fileName = currentFile.name;
  const editor = activeView.editor;
  let selection;
  let lineNumber;
  if (editor.somethingSelected()) {
    selection = editor.getSelection();
    const cursor2 = editor.getCursor("from");
    lineNumber = cursor2.line + 1;
  }
  const fullContent = editor.getValue();
  const cursor = editor.getCursor();
  const cursorPosition = editor.posToOffset(cursor);
  return {
    activeView,
    currentFile,
    fileName,
    selection,
    fullContent,
    cursorPosition,
    lineNumber
  };
}
var AutoLoadManager = class {
  /**
   * Creates a new AutoLoadManager instance
   *
   * @param app - Obsidian App instance for accessing workspace and editor
   * @param loadTextCallback - Callback function to load text into DashReader view
   * @param isViewShown - Function that returns true if DashReader view is currently visible
   * @param timeoutManager - Timeout manager for proper cleanup
   *
   * @example
   * ```typescript
   * this.autoLoadManager = new AutoLoadManager(
   *   this.app,
   *   (text, source) => this.loadText(text, source),
   *   () => this.isViewShown,
   *   this.timeoutManager
   * );
   * ```
   */
  constructor(app, loadTextCallback, isViewShown, timeoutManager) {
    this.app = app;
    this.loadTextCallback = loadTextCallback;
    this.isViewShown = isViewShown;
    this.timeoutManager = timeoutManager;
    this.state = {
      lastSelection: "",
      lastFilePath: "",
      lastCursorPosition: -1,
      lastCheckTime: 0
    };
  }
  /**
   * Check for selection or cursor changes and load text if needed
   *
   * This is the main method called by keyboard and mouse event handlers.
   * It implements throttling (150ms) to avoid performance issues from
   * rapid event firing.
   *
   * **Logic Flow**:
   * 1. Throttle: Skip if less than 150ms since last check
   * 2. Extract editor content (selection, cursor position, etc.)
   * 3. Priority 1: If selection exists and changed → load selection
   * 4. Priority 2: If cursor moved → reload from new cursor position
   *
   * **Prevents Redundant Loads**:
   * - Tracks lastSelection to avoid reloading same text
   * - Tracks lastCursorPosition to avoid reload on unchanged position
   *
   * **Typical Usage**: Called on keyup and mouseup events
   *
   * @example
   * ```typescript
   * // In rsvp-view.ts setupAutoLoad()
   * this.registerDomEvent(document, 'keyup', (evt) => {
   *   if (isNavigationKey(evt) || isSelectionKey(evt)) {
   *     this.autoLoadManager.checkSelectionOrCursor();
   *   }
   * });
   *
   * this.registerDomEvent(document, 'mouseup', () => {
   *   this.autoLoadManager.checkSelectionOrCursor();
   * });
   * ```
   */
  syncStateToEditor() {
    var _a;
    const content = extractEditorContent(this.app);
    if (!content.currentFile)
      return;
    this.state.lastFilePath = content.currentFile.path;
    this.state.lastSelection = (_a = content.selection) != null ? _a : "";
    if (typeof content.cursorPosition === "number") {
      this.state.lastCursorPosition = content.cursorPosition;
    }
  }
  checkSelectionOrCursor() {
    var _a, _b;
    const now = Date.now();
    if (now - this.state.lastCheckTime < TIMING.throttleDelay) {
      return;
    }
    this.state.lastCheckTime = now;
    const content = extractEditorContent(this.app);
    if (!content.activeView || !content.currentFile) {
      return;
    }
    if (content.selection && content.selection.length > TEXT_LIMITS.minSelectionLength) {
      if (content.selection !== this.state.lastSelection) {
        this.state.lastFilePath = content.currentFile.path;
        this.state.lastSelection = content.selection;
        this.state.lastCursorPosition = (_a = content.cursorPosition) != null ? _a : this.state.lastCursorPosition;
        this.loadTextCallback(content.selection, {
          fileName: content.fileName,
          lineNumber: content.lineNumber
        });
      }
      return;
    }
    if (content.fullContent && content.fullContent.trim().length > TEXT_LIMITS.minContentLength) {
      if (content.cursorPosition !== this.state.lastCursorPosition) {
        this.state.lastFilePath = content.currentFile.path;
        this.state.lastSelection = "";
        this.state.lastCursorPosition = (_b = content.cursorPosition) != null ? _b : this.state.lastCursorPosition;
        this.loadTextCallback(content.fullContent, {
          fileName: content.fileName,
          cursorPosition: content.cursorPosition
        });
      }
    }
  }
  /**
   * Load content from the active editor with a configurable delay
   *
   * Used by file-open and leaf-change events to load content after a short
   * delay, giving Obsidian time to fully activate the editor.
   *
   * **Priority Logic**:
   * 1. If text is selected → load selection (rare on file open)
   * 2. Otherwise → load full document from cursor position
   *
   * **Delay Rationale**:
   * - file-open: 300ms default - editor needs time to initialize
   * - leaf-change: Can use shorter delay (200ms) - editor already active
   *
   * @param delay - Delay in milliseconds before loading (default: 300ms from TIMING.autoLoadDelay)
   *
   * @example
   * ```typescript
   * // File-open event (use default 300ms delay)
   * this.registerEvent(
   *   this.app.workspace.on('file-open', () => {
   *     this.autoLoadManager.loadFromEditor();
   *   })
   * );
   *
   * // Leaf-change event (use shorter 200ms delay)
   * this.registerEvent(
   *   this.app.workspace.on('active-leaf-change', () => {
   *     this.autoLoadManager.loadFromEditor(TIMING.autoLoadDelayShort);
   *   })
   * );
   * ```
   */
  loadFromEditor(delay = TIMING.autoLoadDelay) {
    this.timeoutManager.setTimeout(() => {
      var _a, _b;
      if (!this.isViewShown())
        return;
      const content = extractEditorContent(this.app);
      if (!content.activeView || !content.currentFile)
        return;
      if (content.selection && content.selection.length > TEXT_LIMITS.minSelectionLength) {
        this.state.lastFilePath = content.currentFile.path;
        this.state.lastSelection = content.selection;
        this.state.lastCursorPosition = (_a = content.cursorPosition) != null ? _a : this.state.lastCursorPosition;
        this.loadTextCallback(content.selection, {
          fileName: content.fileName,
          lineNumber: content.lineNumber
        });
        return;
      }
      if (content.fullContent && content.fullContent.trim().length > TEXT_LIMITS.minContentLength) {
        this.state.lastFilePath = content.currentFile.path;
        this.state.lastSelection = "";
        this.state.lastCursorPosition = (_b = content.cursorPosition) != null ? _b : this.state.lastCursorPosition;
        this.loadTextCallback(content.fullContent, {
          fileName: content.fileName,
          cursorPosition: content.cursorPosition
        });
      }
    }, delay);
  }
  /**
   * Reset tracking state for a new file
   *
   * Called when the active file changes to clear previous selection and
   * cursor tracking. This prevents attempting to reload content from the
   * previous file's state.
   *
   * @param filePath - Path of the newly opened file
   *
   * @example
   * ```typescript
   * this.registerEvent(
   *   this.app.workspace.on('file-open', (file) => {
   *     if (file && this.autoLoadManager.hasFileChanged(file.path)) {
   *       this.autoLoadManager.resetForNewFile(file.path);
   *       this.autoLoadManager.loadFromEditor();
   *     }
   *   })
   * );
   * ```
   */
  resetForNewFile(filePath) {
    this.state.lastSelection = "";
    this.state.lastFilePath = filePath;
    this.state.lastCursorPosition = -1;
  }
  /**
   * Check if the file has changed
   *
   * Compares the given file path with the last tracked file path to determine
   * if the user has switched to a different file.
   *
   * @param filePath - File path to check
   * @returns True if the file path is different from the last tracked path
   *
   * @example
   * ```typescript
   * if (this.autoLoadManager.hasFileChanged(currentFile.path)) {
   *   console.log('User switched to a different file');
   *   this.autoLoadManager.resetForNewFile(currentFile.path);
   * }
   * ```
   */
  hasFileChanged(filePath) {
    return filePath !== this.state.lastFilePath;
  }
  /**
   * Get current state (for debugging)
   *
   * Returns a readonly copy of the internal state for debugging purposes.
   * Useful for understanding why auto-load is or isn't triggering.
   *
   * @returns Readonly copy of the current AutoLoadState
   *
   * @example
   * ```typescript
   * const state = this.autoLoadManager.getState();
   * console.log('AutoLoad state:', {
   *   lastSelection: state.lastSelection.substring(0, 50) + '...',
   *   lastFilePath: state.lastFilePath,
   *   lastCursorPosition: state.lastCursorPosition,
   *   lastCheckTime: new Date(state.lastCheckTime).toISOString()
   * });
   * ```
   */
  getState() {
    return { ...this.state };
  }
};

// src/rsvp-view.ts
var _DashReaderView = class extends import_obsidian5.Modal {
  // ──────────────────────────────────────────────────────────────────────
  // Constructor
  // ──────────────────────────────────────────────────────────────────────
  /**
   * Creates a new DashReaderView instance
   *
   * @param leaf - Obsidian workspace leaf to attach to
   * @param settings - Plugin settings
   */
  constructor(app, settings, onModalClose, onSettingsSave) {
    super(app);
    this.isOpen = false;
    // debounce handle (so we don't write data.json 30 times in a second)
    this._saveSettingsTimer = null;
    this.isInitialized = false;
    this.pendingLoad = null;
    this.skipInitialAutoLoad = false;
    this.keydownHandler = null;
    this._eventRefs = [];
    this._domUnsubs = [];
    // Keep existing call sites working:
    this._eventUnsubs = [];
    this.headingNav = { lastTime: 0, dir: null, cursor: null };
    /** Track whether we paused due to opening a panel */
    this.pausedByPanelOpen = false;
    this.wasPlayingBeforePanelOpen = false;
    // Add near other fields in the class:
    this.progressBarEl = null;
    this.isProgressBarHovering = false;
    this.progressBarHoverIndex = null;
    this.progressBarHoverRaf = null;
    this.progressBarLastTooltipIndex = null;
    this.progressInfoLeftEl = null;
    this.progressInfoRightEl = null;
    this.suppressAutoLoadUntil = 0;
    this.sessionStartIndex = 0;
    this.sessionTotalTokens = 0;
    this.sessionTotalDurationSec = 0;
    this.ignoreNextDisplayToggleClick = false;
    this._contextUpdateRaf = null;
    this._pendingContextIndex = null;
    this.suppressContextUntilPlay = true;
    this.lastDisplayedIndex = null;
    this.settings = settings;
    this.onModalClose = onModalClose;
    this.onSettingsSave = onSettingsSave;
    this.state = new ViewState({
      currentWpm: this.isMobileUI() ? settings.mobileWpm : settings.wpm,
      currentChunkSize: this.isMobileUI() ? settings.mobileChunkSize : settings.chunkSize,
      currentFontSize: this.getActiveFontSize()
    });
    this.dom = new DOMRegistry();
    this.timeoutManager = new TimeoutManager();
    this.engine = new RSVPEngine(
      settings,
      this.onWordChange.bind(this),
      this.timeoutManager
    );
    this.engine.setUseMobileProfile(this.isMobileUI());
    this.autoLoadManager = new AutoLoadManager(
      this.app,
      this.loadText.bind(this),
      () => {
        var _a, _b;
        return (_b = (_a = this.mainContainerEl) == null ? void 0 : _a.isShown()) != null ? _b : false;
      },
      this.timeoutManager
    );
  }
  registerEvent(emitter, ref) {
    this._eventUnsubs.push(() => {
      try {
        emitter.offref(ref);
      } catch (e) {
      }
    });
  }
  registerDomEvent(target, type, listener, options) {
    target.addEventListener(type, listener, options);
    this._domUnsubs.push(() => target.removeEventListener(type, listener, options));
  }
  _cleanupRegistered() {
    for (const unsub of this._eventUnsubs)
      unsub();
    this._eventUnsubs = [];
    for (const unsub of this._domUnsubs)
      unsub();
    this._domUnsubs = [];
  }
  isMobileUI() {
    var _a, _b, _c;
    const p = import_obsidian5.Platform;
    if (typeof (p == null ? void 0 : p.isMobileApp) === "boolean")
      return p.isMobileApp;
    if (typeof (p == null ? void 0 : p.isMobile) === "boolean")
      return p.isMobile;
    const a = this.app;
    if (typeof (a == null ? void 0 : a.isMobile) === "boolean")
      return a.isMobile;
    return (_c = (_b = (_a = window.matchMedia) == null ? void 0 : _a.call(window, "(hover: none) and (pointer: coarse)")) == null ? void 0 : _b.matches) != null ? _c : false;
  }
  getActiveFontSize() {
    return this.isMobileUI() ? this.settings.mobileFontSize : this.settings.fontSize;
  }
  // ──────────────────────────────────────────────────────────────────────
  // Obsidian View Lifecycle
  // ──────────────────────────────────────────────────────────────────────
  /**
   * Called when the view is opened
   * Builds UI, sets up hotkeys, and registers auto-load
   */
  async onOpen() {
    var _a, _b;
    this.isOpen = true;
    this.contentEl.empty();
    this.modalEl.addClass("dashreader-modal");
    this.containerEl.addClass("dashreader-modal-container");
    (_a = this.modalEl.querySelector(".modal-close-button")) == null ? void 0 : _a.remove();
    (_b = this.modalEl.querySelector(".modal-header")) == null ? void 0 : _b.remove();
    this.modalEl.setAttr("tabindex", "-1");
    this.applyAppearanceCssVars();
    this.mainContainerEl = this.contentEl.createDiv({ cls: CSS_CLASSES.container });
    this.mainContainerEl.style.fontFamily = this.settings.fontFamily || "inherit";
    this.buildUI();
    this.engine.setUseMobileProfile(this.isMobileUI());
    this.syncBoldColorToTheme();
    this.suppressContextUntilPlay = true;
    this.toggleContextDisplay();
    this.breadcrumbManager = new BreadcrumbManager(this.breadcrumbEl, this.engine, this.timeoutManager, {
      onPlayStateChange: (isPlaying) => updatePlayPauseButtons(this.dom, isPlaying),
      canAutoResume: () => !this.isAnyInlinePanelOpen()
    });
    this.wordDisplay = new WordDisplay(
      this.wordEl,
      this.settings,
      this.getActiveFontSize(),
      this.engine.getChunkSize()
    );
    this.hotkeyHandler = new HotkeyHandler(this.settings, {
      onTogglePlay: () => this.togglePlay(),
      onRewind: () => this.engine.rewindSeconds(10),
      onForward: () => this.engine.forwardSeconds(10),
      onIncrementWpm: () => this.changeValue("wpm", INCREMENTS.wpm),
      onDecrementWpm: () => this.changeValue("wpm", -INCREMENTS.wpm),
      onQuit: () => this.engine.stop()
    });
    this.engine.setUseMobileProfile(this.isMobileUI());
    this.toggleContextDisplay();
    this.toggleBreadcrumbDisplay();
    this.setupOutsideClickToClosePanels();
    this.defocusInteractiveElements();
    requestAnimationFrame(() => this.defocusInteractiveElements());
    this.setupHotkeys();
    this.app.workspace.onLayoutReady(() => {
      this.setupAutoLoad();
      const hasExplicitLoadQueued = !!this.pendingLoad || this.engine.getTotalWords() > 0;
      if (!this.skipInitialAutoLoad && !hasExplicitLoadQueued) {
        this.autoLoadManager.loadFromEditor(50);
      }
      this.skipInitialAutoLoad = false;
      this.timeoutManager.setTimeout(() => {
        if (this.engine.getTotalWords() === 0) {
          this.wordDisplay.displayWelcomeMessage(
            ICONS.book,
            "Select text to start reading",
            'or use Cmd+P \u2192 "Read selected text"'
          );
        }
      }, 500);
    });
    this.isInitialized = true;
    if (this.pendingLoad) {
      const { text, source } = this.pendingLoad;
      this.pendingLoad = null;
      this.loadText(text, source);
    }
  }
  /**
   * Called when the view is closed
   * Stops reading and cleans up resources
   */
  async onClose() {
    var _a;
    this.isOpen = false;
    this._cleanupRegistered();
    this.engine.stop();
    this.timeoutManager.clearAll();
    this.dom.clear();
    if (this.keydownHandler) {
      document.removeEventListener("keydown", this.keydownHandler);
      this.keydownHandler = null;
    }
    this.contentEl.empty();
    (_a = this.onModalClose) == null ? void 0 : _a.call(this);
    this.requestSettingsSave();
  }
  // ============================================================================
  // SECTION 3: UI CONSTRUCTION
  // ============================================================================
  /**
   * Orchestrates the construction of all UI components
   * Called once during view initialization
   *
   * Order matters: toggle bar, breadcrumb, display, progress, controls, settings
   */
  buildUI() {
    this.buildToggleBar();
    this.buildBreadcrumb();
    this.buildDisplayArea();
    this.buildProgressBar();
    this.buildInlineSettings();
  }
  /**
   * Builds the toggle bar with settings button
   * Located at the top of the view
   */
  buildToggleBar() {
    this.toggleBar = this.mainContainerEl.createDiv({ cls: CSS_CLASSES.toggleBar });
    this.controlsToggleBtn = createButton(this.toggleBar, {
      icon: ICONS.settings,
      title: "Toggle Settings (S)",
      onClick: () => this.togglePanel("controls"),
      className: CSS_CLASSES.toggleBtn
    });
  }
  /**
   * Builds the breadcrumb navigation bar
   * Shows the hierarchical position in the document (H1 > H2 > H3 etc.)
   * Updated automatically as reading progresses through headings
   */
  buildBreadcrumb() {
    this.breadcrumbEl = this.mainContainerEl.createDiv({
      cls: `dashreader-breadcrumb ${CSS_CLASSES.hidden}`
    });
  }
  /**
   * Builds the main display area for word presentation
   * Includes context before/after if enabled
   */
  buildDisplayArea() {
    const displayArea = this.mainContainerEl.createDiv({ cls: CSS_CLASSES.display });
    const showContextNow = this.getActiveShowContext() && this.engine.getTotalWords() > 0 && !this.suppressContextUntilPlay;
    let displayPointerDown = false;
    let displayPointerMoved = false;
    let displayPointerX = 0;
    let displayPointerY = 0;
    let displayPointerId = null;
    let displayShouldToggle = false;
    const computeShouldToggle = (target) => {
      if (!target)
        return false;
      const clickedInWord = !!target.closest(`.${CSS_CLASSES.word}`);
      if (!clickedInWord && target.closest("button, a, input, textarea, select, .dashreader-outline-menu"))
        return false;
      return true;
    };
    this.registerDomEvent(displayArea, "pointerdown", (e) => {
      if (e.button !== 0)
        return;
      const shouldToggle = computeShouldToggle(e.target);
      if (!shouldToggle)
        return;
      displayPointerDown = true;
      displayPointerMoved = false;
      displayPointerX = e.clientX;
      displayPointerY = e.clientY;
      displayPointerId = e.pointerId;
      displayShouldToggle = true;
      const t = e.target;
      const startedInContext = !!(t == null ? void 0 : t.closest(
        `.${CSS_CLASSES.contextBefore}, .${CSS_CLASSES.contextAfter}`
      ));
      if (!startedInContext) {
        try {
          displayArea.setPointerCapture(e.pointerId);
        } catch (e2) {
        }
      }
    }, { capture: true });
    this.registerDomEvent(
      displayArea,
      "pointermove",
      (e) => {
        if (!displayPointerDown || displayPointerId !== e.pointerId)
          return;
        const dx = e.clientX - displayPointerX;
        const dy = e.clientY - displayPointerY;
        if (Math.abs(dx) > 6 || Math.abs(dy) > 6)
          displayPointerMoved = true;
      },
      { capture: true }
    );
    const resetDisplayPointer = (e) => {
      if (e && displayPointerId === e.pointerId) {
        try {
          displayArea.releasePointerCapture(e.pointerId);
        } catch (e2) {
        }
      }
      displayPointerDown = false;
      displayPointerMoved = false;
      displayPointerId = null;
      displayShouldToggle = false;
    };
    this.registerDomEvent(
      displayArea,
      "pointerup",
      (e) => {
        if (displayPointerId !== e.pointerId)
          return;
        const shouldToggle = displayShouldToggle && !displayPointerMoved;
        resetDisplayPointer(e);
        if (!shouldToggle)
          return;
        if (this.ignoreNextDisplayToggleClick) {
          this.ignoreNextDisplayToggleClick = false;
          return;
        }
        this.togglePlay();
      },
      { capture: true }
    );
    this.registerDomEvent(
      displayArea,
      "pointercancel",
      (e) => resetDisplayPointer(e),
      { capture: true }
    );
    let wheelAccum = 0;
    let wheelDir = 0;
    const WHEEL_THRESHOLD = 80;
    this.registerDomEvent(
      displayArea,
      "wheel",
      (e) => {
        if (this.engine.getIsPlaying())
          return;
        if (e.ctrlKey || e.metaKey)
          return;
        const t = e.target;
        if (t == null ? void 0 : t.closest("button, a, input, textarea, select, .dashreader-outline-menu"))
          return;
        e.preventDefault();
        let dy = e.deltaY;
        if (e.deltaMode === 1)
          dy *= 16;
        else if (e.deltaMode === 2)
          dy *= 800;
        const dir = Math.sign(dy);
        if (dir !== 0 && dir !== wheelDir) {
          wheelAccum = 0;
          wheelDir = dir;
        }
        wheelAccum += dy;
        if (wheelAccum >= WHEEL_THRESHOLD) {
          wheelAccum -= WHEEL_THRESHOLD;
          wheelAccum = Math.min(wheelAccum, WHEEL_THRESHOLD - 1);
          this.engine.stepWords(1);
        } else if (wheelAccum <= -WHEEL_THRESHOLD) {
          wheelAccum += WHEEL_THRESHOLD;
          wheelAccum = Math.max(wheelAccum, -(WHEEL_THRESHOLD - 1));
          this.engine.stepWords(-1);
        }
      },
      { passive: false, capture: true }
    );
    this.contextBeforeEl = displayArea.createDiv({
      cls: `${CSS_CLASSES.contextBefore} ${showContextNow ? "" : CSS_CLASSES.hidden}`
    });
    this.dom.register("contextBeforeEl", this.contextBeforeEl);
    this.contextBeforeEl.style.whiteSpace = "pre-wrap";
    this.applyContextLayout();
    this.wordEl = displayArea.createDiv({ cls: CSS_CLASSES.word });
    this.wordEl.style.setProperty("font-size", `${this.getActiveFontSize()}px`, "important");
    this.wordEl.style.fontFamily = this.settings.fontFamily;
    this.wordEl.style.textShadow = "none";
    this.wordEl.style.filter = "none";
    this.dom.register("wordEl", this.wordEl);
    this.contextAfterEl = displayArea.createDiv({
      cls: `${CSS_CLASSES.contextAfter} ${showContextNow ? "" : CSS_CLASSES.hidden}`
    });
    this.dom.register("contextAfterEl", this.contextAfterEl);
    this.contextAfterEl.style.whiteSpace = "pre-wrap";
    this.applyContextLayout();
    this.setContextScrollEnabled(!this.engine.getIsPlaying());
    this.ensureContextMeasureHost();
    this.setupContextResizeObserver();
  }
  /**
   * Builds the progress bar at the bottom of display
   * Updates during reading to show progress
   */
  buildProgressBar() {
    this.bottomBarEl = this.mainContainerEl.createDiv({ cls: "dashreader-bottom-bar" });
    this.progressEl = this.bottomBarEl.createDiv({ cls: CSS_CLASSES.progressContainer });
    this.progressBarEl = this.progressEl.createEl("progress", {
      cls: "metadata-progress rsvp-progress-bar"
    });
    this.registerDomEvent(this.progressBarEl, "pointerdown", (e) => {
      if (e.button !== 0)
        return;
      const bar = this.progressBarEl;
      if (!bar)
        return;
      const rect = bar.getBoundingClientRect();
      const x = Math.max(0, Math.min(rect.width, e.clientX - rect.left));
      const ratio = rect.width > 0 ? x / rect.width : 0;
      const total = this.engine.getTotalWords();
      if (total <= 0)
        return;
      const targetIndex = Math.min(total - 1, Math.max(0, Math.floor(ratio * (total - 1))));
      const wasPlaying = this.engine.getIsPlaying();
      this.engine.jumpToIndex(targetIndex);
      this.updateBottomProgressInfo(targetIndex);
      if (!wasPlaying) {
        this.engine.pause();
        updatePlayPauseButtons(this.dom, false);
        this.setContextScrollEnabled(true);
        if (this.getActiveShowContext())
          this.scheduleContextUpdate(this.getContextAnchorIndex());
      }
    }, { capture: true });
    this.registerDomEvent(this.progressBarEl, "pointerenter", (e) => {
      this.isProgressBarHovering = true;
      this.progressBarLastTooltipIndex = null;
      this.updateProgressTooltipForClientX(e.clientX);
    });
    this.registerDomEvent(this.progressBarEl, "pointermove", (e) => {
      if (!this.isProgressBarHovering)
        return;
      this.updateProgressTooltipForClientX(e.clientX);
    });
    this.registerDomEvent(this.progressBarEl, "pointerleave", () => {
      this.isProgressBarHovering = false;
      this.progressBarHoverIndex = null;
      this.progressBarLastTooltipIndex = null;
      if (this.progressBarHoverRaf !== null) {
        cancelAnimationFrame(this.progressBarHoverRaf);
        this.progressBarHoverRaf = null;
      }
      this.restoreProgressTooltipToPercent();
    });
    this.dom.register("progressBar", this.progressBarEl);
    this.progressBarEl.style.display = this.settings.showProgress ? "" : "none";
    this.progressBarEl.max = Math.max(1, this.engine.getTotalWords());
    this.progressBarEl.value = Math.min(this.progressBarEl.max, this.getContextAnchorIndex() + 1);
    this.progressBarEl.setAttr("data-tooltip-position", "top");
    this.progressBarEl.setAttr("data-tooltip-delay", "0");
    this.restoreProgressTooltipToPercent();
    this.buildMobileControls();
  }
  refreshContextNow() {
    if (!this.getActiveShowContext() || !this.contextBeforeEl || !this.contextAfterEl)
      return;
    const idx = this.getContextAnchorIndex();
    const ctx = this.engine.getContextLines(idx, this.getActiveContextLines());
    this.contextBeforeEl.setText(this.renderContextTokens(ctx.before));
    this.contextAfterEl.setText(this.renderContextTokens(ctx.after));
  }
  applyAppearanceCssVars() {
    const root = this.modalEl;
    if (!root)
      return;
    const apply = (name, value) => {
      const v = (value != null ? value : "").trim();
      if (!v || v.toLowerCase() === "theme")
        root.style.removeProperty(name);
      else
        root.style.setProperty(name, v);
    };
    apply("--dashreader-highlight-color", this.settings.highlightColor);
    apply("--dashreader-font-color", this.settings.fontColor);
    apply("--dashreader-background-color", this.settings.backgroundColor);
  }
  ensureContextMeasureHost() {
    if (this._contextMeasureHostEl)
      return;
    const host = this.modalEl.createDiv();
    host.style.position = "fixed";
    host.style.left = "-100000px";
    host.style.top = "0";
    host.style.visibility = "hidden";
    host.style.pointerEvents = "none";
    host.style.zIndex = "-1";
    host.style.overflow = "visible";
    const mk = () => {
      const el = host.createDiv();
      el.style.boxSizing = "border-box";
      el.style.whiteSpace = "pre-wrap";
      el.style.overflowWrap = "anywhere";
      el.style.wordBreak = "break-word";
      return el;
    };
    this._contextMeasureHostEl = host;
    this._contextMeasureBeforeEl = mk();
    this._contextMeasureAfterEl = mk();
  }
  syncMeasureStyle(fromEl, measureEl) {
    const cs = getComputedStyle(fromEl);
    const w = fromEl.getBoundingClientRect().width;
    measureEl.style.width = `${Math.max(1, w)}px`;
    measureEl.style.padding = cs.padding;
    measureEl.style.fontFamily = cs.fontFamily;
    measureEl.style.fontSize = cs.fontSize;
    measureEl.style.fontWeight = cs.fontWeight;
    measureEl.style.lineHeight = cs.lineHeight;
    measureEl.style.letterSpacing = cs.letterSpacing;
  }
  formatTime(seconds) {
    const s = Math.max(0, Math.round(seconds));
    const mins = Math.floor(s / 60);
    const secs = s % 60;
    return `${mins}:${secs.toString().padStart(2, "0")}`;
  }
  getWrappedLinesSubset(text, targetEl, measureEl, count, mode) {
    var _a;
    const n = Math.max(0, Math.floor(count));
    if (n === 0)
      return [];
    this.syncMeasureStyle(targetEl, measureEl);
    measureEl.setText(text != null ? text : "");
    const node = measureEl.firstChild;
    if (!node || node.nodeType !== Node.TEXT_NODE) {
      return mode === "first" ? Array(n).fill("") : Array(n).fill("");
    }
    const textNode = node;
    const full = (_a = textNode.data) != null ? _a : "";
    const len = full.length;
    if (len === 0) {
      return mode === "first" ? Array(n).fill("") : Array(n).fill("");
    }
    const range = document.createRange();
    range.setStart(textNode, 0);
    range.setEnd(textNode, len);
    const rects = Array.from(range.getClientRects());
    if (rects.length === 0) {
      return mode === "first" ? Array(n).fill("") : Array(n).fill("");
    }
    const tops = [];
    for (const r of rects) {
      const t = Math.round(r.top);
      if (!tops.length || Math.abs(t - tops[tops.length - 1]) > 1)
        tops.push(t);
    }
    const totalLines = tops.length;
    const startLine = mode === "first" ? 0 : Math.max(0, totalLines - n);
    const endLineExcl = mode === "first" ? Math.min(totalLines, n) : totalLines;
    const lastTopAt = (end) => {
      const e = Math.max(0, Math.min(len, end));
      if (e === 0)
        return -Infinity;
      range.setStart(textNode, 0);
      range.setEnd(textNode, e);
      const rs = range.getClientRects();
      if (!rs.length)
        return -Infinity;
      return Math.round(rs[rs.length - 1].top);
    };
    const findStartOffsetForTop = (targetTop) => {
      let lo = 1;
      let hi = len;
      while (lo < hi) {
        const mid = lo + hi >> 1;
        const t = lastTopAt(mid);
        if (t < targetTop)
          lo = mid + 1;
        else
          hi = mid;
      }
      return Math.max(0, lo - 1);
    };
    const offsets = [];
    for (let i = startLine; i < endLineExcl; i++) {
      offsets.push(i === 0 ? 0 : findStartOffsetForTop(tops[i]));
    }
    const endOffset = endLineExcl < totalLines ? findStartOffsetForTop(tops[endLineExcl]) : len;
    offsets.push(endOffset);
    const lines = [];
    for (let i = 0; i < offsets.length - 1; i++) {
      let seg = full.slice(offsets[i], offsets[i + 1]);
      seg = seg.replace(/^\n+/, "");
      seg = seg.replace(/\n+$/, "");
      seg = seg.replace(/^\s+/, "");
      seg = seg.trimEnd();
      lines.push(seg);
    }
    if (mode === "first") {
      while (lines.length < n)
        lines.push("");
    } else {
      while (lines.length < n)
        lines.unshift("");
    }
    return lines;
  }
  getContextAnchorIndex() {
    var _a;
    return (_a = this.lastDisplayedIndex) != null ? _a : this.engine.getCurrentIndex();
  }
  scheduleContextUpdate(index) {
    this._pendingContextIndex = index;
    if (this._contextUpdateRaf !== null)
      return;
    this._contextUpdateRaf = window.requestAnimationFrame(() => {
      this._contextUpdateRaf = null;
      const idx = this._pendingContextIndex;
      this._pendingContextIndex = null;
      if (idx == null)
        return;
      this.updateContextByBrowserWrap(idx);
    });
  }
  updateContextByBrowserWrap(wordIndex) {
    if (!this.getActiveShowContext() || !this.contextBeforeEl || !this.contextAfterEl)
      return;
    const extraLines = Math.max(0, this.getActiveContextLines());
    const visibleLines = extraLines + 1;
    this.ensureContextMeasureHost();
    if (!this._contextMeasureBeforeEl || !this._contextMeasureAfterEl)
      return;
    const windowTokens = Math.max(300, visibleLines * 80);
    const ctx = this.engine.getContextTokenWindow(wordIndex, windowTokens, windowTokens);
    const beforeText = this.renderContextTokens(ctx.before);
    const afterText = this.renderContextTokens(ctx.after);
    const beforeLines = this.getWrappedLinesSubset(
      beforeText,
      this.contextBeforeEl,
      this._contextMeasureBeforeEl,
      visibleLines,
      "last"
    );
    const afterLines = this.getWrappedLinesSubset(
      afterText,
      this.contextAfterEl,
      this._contextMeasureAfterEl,
      visibleLines,
      "first"
    );
    this.contextBeforeEl.setText(beforeLines.join("\n"));
    this.contextAfterEl.setText(afterLines.join("\n"));
  }
  setupContextResizeObserver() {
    if (this._contextResizeObserver || !this.contextBeforeEl || !this.contextAfterEl)
      return;
    const ro = new ResizeObserver(() => {
      this.scheduleContextUpdate(this.getContextAnchorIndex());
    });
    ro.observe(this.contextBeforeEl);
    ro.observe(this.contextAfterEl);
    this._contextResizeObserver = ro;
    this._domUnsubs.push(() => {
      try {
        ro.disconnect();
      } catch (e) {
      }
    });
  }
  buildMobileControls() {
    this.mobileControlsEl = this.bottomBarEl.createDiv({ cls: "dashreader-mobile-controls" });
    const wrap = this.mobileControlsEl.createDiv({ cls: "dashreader-mobile-controls-wrap" });
    this.progressInfoLeftEl = wrap.createSpan({
      cls: "dashreader-progress-info dashreader-progress-info-left"
    });
    const row = wrap.createDiv({ cls: "dashreader-mobile-controls-row" });
    this.progressInfoRightEl = wrap.createSpan({
      cls: "dashreader-progress-info dashreader-progress-info-right"
    });
    this.updateBottomProgressInfo();
    createButton(row, {
      icon: "lucide:chevrons-left",
      title: "Jump to start (Ctrl+\u2190)",
      onClick: () => {
        this.engine.jumpToStart();
        this.defocusInteractiveElements();
      },
      className: CSS_CLASSES.toggleBtn
    });
    createButton(row, {
      icon: "lucide:arrow-up",
      title: "Previous heading (\u2191)",
      onClick: () => {
        this.jumpHeading("up");
        this.defocusInteractiveElements();
      },
      className: CSS_CLASSES.toggleBtn
    });
    createButton(row, {
      icon: "lucide:arrow-left",
      title: "Rewind (\u2190)",
      onClick: () => {
        this.engine.rewindSeconds(10);
        this.defocusInteractiveElements();
      },
      className: CSS_CLASSES.toggleBtn
    });
    createPlayPauseButtons(
      row,
      () => {
        if (!this.engine.getIsPlaying())
          this.togglePlay();
        else
          this.defocusInteractiveElements();
      },
      () => {
        if (this.engine.getIsPlaying())
          this.togglePlay();
        else
          this.defocusInteractiveElements();
      },
      this.dom
    );
    updatePlayPauseButtons(this.dom, this.engine.getIsPlaying());
    createButton(row, {
      icon: "lucide:arrow-right",
      title: "Forward (\u2192)",
      onClick: () => {
        this.engine.forwardSeconds(10);
        this.defocusInteractiveElements();
      },
      className: CSS_CLASSES.toggleBtn
    });
    createButton(row, {
      icon: "lucide:arrow-down",
      title: "Next heading (\u2193)",
      onClick: () => {
        this.jumpHeading("down");
        this.defocusInteractiveElements();
      },
      className: CSS_CLASSES.toggleBtn
    });
    createButton(row, {
      icon: "lucide:chevrons-right",
      title: "Jump to end (Ctrl+\u2192)",
      onClick: () => {
        this.engine.jumpToEnd();
        this.defocusInteractiveElements();
      },
      className: CSS_CLASSES.toggleBtn
    });
  }
  /**
   * Builds the inline settings panel
   * Allows quick adjustments to WPM, acceleration, font size, etc.
   */
  buildInlineSettings() {
    this.settingsEl = this.mainContainerEl.createDiv({
      cls: `${CSS_CLASSES.settings} ${CSS_CLASSES.hidden}`
    });
    this.dom.register("settingsEl", this.settingsEl);
    createNumberControl(
      this.settingsEl,
      {
        label: "Speed (WPM): ",
        value: this.engine.getWpm(),
        onIncrement: () => this.changeValue("wpm", INCREMENTS.wpm),
        onDecrement: () => this.changeValue("wpm", -INCREMENTS.wpm),
        increment: INCREMENTS.wpm,
        registryKey: "wpmInlineValue",
        decrementTitle: "Slower (-25)",
        incrementTitle: "Faster (+25)"
      },
      this.dom
    );
    createNumberControl(
      this.settingsEl,
      {
        label: "Font Size: ",
        value: this.getActiveFontSize(),
        onIncrement: () => this.changeValue("fontSize", INCREMENTS.fontSize),
        onDecrement: () => this.changeValue("fontSize", -INCREMENTS.fontSize),
        registryKey: "fontValue",
        decrementTitle: "Smaller",
        incrementTitle: "Larger"
      },
      this.dom
    );
    createNumberControl(
      this.settingsEl,
      {
        label: "Words: ",
        value: this.engine.getChunkSize(),
        onIncrement: () => this.changeValue("chunkSize", INCREMENTS.chunkSize),
        onDecrement: () => this.changeValue("chunkSize", -INCREMENTS.chunkSize),
        registryKey: "chunkValue"
      },
      this.dom
    );
    createToggleControl(this.settingsEl, {
      label: "Slow Start",
      checked: this.isMobileUI() ? this.settings.mobileEnableSlowStart : this.settings.enableSlowStart,
      onChange: (checked) => {
        if (this.isMobileUI())
          this.settings.mobileEnableSlowStart = checked;
        else
          this.settings.enableSlowStart = checked;
        this.engine.updateSettings(this.settings);
        this.requestSettingsSave();
      }
    });
    createToggleControl(this.settingsEl, {
      label: "Micropause",
      checked: this.isMobileUI() ? this.settings.mobileEnableMicropause : this.settings.enableMicropause,
      onChange: (checked) => {
        if (this.isMobileUI())
          this.settings.mobileEnableMicropause = checked;
        else
          this.settings.enableMicropause = checked;
        this.engine.updateSettings(this.settings);
        this.requestSettingsSave();
      }
    });
    createToggleControl(this.settingsEl, {
      label: "Breadcrumb",
      checked: this.getActiveShowBreadcrumb(),
      onChange: (checked) => {
        this.setActiveShowBreadcrumb(checked);
        this.toggleBreadcrumbDisplay();
        this.requestSettingsSave();
      }
    });
    createToggleControl(this.settingsEl, {
      label: "Show Context",
      checked: this.getActiveShowContext(),
      onChange: (checked) => {
        this.setActiveShowContext(checked);
        this.toggleContextDisplay();
        if (checked && this.contextBeforeEl && this.contextAfterEl) {
          this.scheduleContextUpdate(this.getContextAnchorIndex());
        }
        ;
        this.requestSettingsSave();
      }
    });
    createNumberControl(
      this.settingsEl,
      {
        label: "Context Lines: ",
        value: this.getActiveContextLines(),
        // reflects current settings (defaults to 10 if that's what settings holds)
        increment: INCREMENTS.contextLines,
        registryKey: "contextLinesValue",
        decrementTitle: "Fewer lines (-1)",
        incrementTitle: "More lines (+1)",
        onIncrement: () => {
          const next = Math.max(0, Math.min(10, this.getActiveContextLines() + INCREMENTS.contextLines));
          this.setActiveContextLines(next);
          this.dom.updateText("contextLinesValue", String(next));
          this.applyContextLayout();
          if (this.getActiveShowContext()) {
            this.scheduleContextUpdate(this.getContextAnchorIndex());
          }
          this.requestSettingsSave();
        },
        onDecrement: () => {
          const next = Math.max(0, Math.min(10, this.getActiveContextLines() - INCREMENTS.contextLines));
          this.setActiveContextLines(next);
          this.dom.updateText("contextLinesValue", String(next));
          this.applyContextLayout();
          if (this.getActiveShowContext()) {
            this.scheduleContextUpdate(this.getContextAnchorIndex());
          }
          this.requestSettingsSave();
        }
      },
      this.dom
    );
  }
  syncBoldColorToTheme() {
    const probe = document.createElement("span");
    probe.style.position = "absolute";
    probe.style.visibility = "hidden";
    probe.innerHTML = "<strong>probe</strong>";
    this.modalEl.appendChild(probe);
    const strongEl = probe.querySelector("strong");
    const boldColor = strongEl ? getComputedStyle(strongEl).color : "";
    probe.remove();
    if (boldColor) {
      this.modalEl.style.setProperty("--dashreader-bold-color", boldColor);
    }
  }
  setContextScrollEnabled(enabled) {
    const before = this.contextBeforeEl;
    const after = this.contextAfterEl;
    for (const el of [before, after]) {
      if (!el)
        continue;
      el.toggleClass("dashreader-context-scrollable-on", enabled);
      el.toggleClass("dashreader-context-scrollable-off", !enabled);
    }
  }
  requestSettingsSave() {
    if (!this.onSettingsSave)
      return;
    if (this._saveSettingsTimer !== null) {
      this.timeoutManager.clearTimeout(this._saveSettingsTimer);
    }
    this._saveSettingsTimer = this.timeoutManager.setTimeout(() => {
      var _a;
      this._saveSettingsTimer = null;
      try {
        (_a = this.onSettingsSave) == null ? void 0 : _a.call(this);
      } catch (e) {
      }
    }, 200);
  }
  // ============================================================================
  // SECTION 4: USER INTERACTIONS
  // ============================================================================
  /**
   * Unified value change handler
   * Replaces 5 separate change functions (changeWpm, changeWpmInline, etc.)
   *
   * @param type - Type of value to change
   * @param delta - Amount to change (positive or negative)
   */
  changeValue(type, delta) {
    var _a, _b;
    switch (type) {
      case "wpm": {
        const newWpm = this.engine.getWpm() + delta;
        this.engine.setWpm(newWpm);
        const wpm = this.engine.getWpm();
        this.state.set("currentWpm", wpm);
        this.dom.updateMultipleText({
          wpmValue: String(wpm),
          wpmInlineValue: String(wpm)
        });
        break;
      }
      case "chunkSize": {
        const newSize = this.engine.getChunkSize() + delta;
        this.engine.setChunkSize(newSize);
        const size = this.engine.getChunkSize();
        this.state.set("currentChunkSize", size);
        this.dom.updateText("chunkValue", size);
        (_a = this.wordDisplay) == null ? void 0 : _a.setChunkSize(size);
        break;
      }
      case "fontSize": {
        const key = this.isMobileUI() ? "mobileFontSize" : "fontSize";
        const next = Math.max(
          LIMITS.fontSize.min,
          Math.min(LIMITS.fontSize.max, this.settings[key] + delta)
        );
        this.settings[key] = next;
        this.state.set("currentFontSize", next);
        if (this.wordEl)
          this.wordEl.style.fontSize = `${next}px`;
        this.dom.updateText("fontValue", next);
        (_b = this.wordDisplay) == null ? void 0 : _b.setBaseFontSize(next);
        break;
      }
    }
    this.requestSettingsSave();
  }
  /**
   * Unified panel toggle handler
   * Replaces 3 separate toggle functions (toggleControls, etc.)
   *
   * @param panel - Panel to toggle ('controls')
   */
  togglePanel(panel) {
    const wasAnyOpen = this.isAnyInlinePanelOpen();
    if (panel === "controls") {
      this.state.toggle("showingControls");
      const showing = this.state.get("showingControls");
      this.settingsEl.toggleClass(CSS_CLASSES.hidden, !showing);
    }
    const isAnyOpenNow = this.isAnyInlinePanelOpen();
    if (!wasAnyOpen && isAnyOpenNow) {
      this.pausePlaybackForInlinePanel();
    }
    if (wasAnyOpen && !isAnyOpenNow) {
      this.resumePlaybackAfterInlinePanelsClose();
    }
    this.defocusInteractiveElements();
  }
  isAnyInlinePanelOpen() {
    return !!this.state.get("showingControls");
  }
  pausePlaybackForInlinePanel() {
    if (!this.engine.getIsPlaying())
      return;
    this.wasPlayingBeforePanelOpen = true;
    this.pausedByPanelOpen = true;
    this.engine.pause();
    updatePlayPauseButtons(this.dom, false);
    this.setContextScrollEnabled(true);
  }
  resumePlaybackAfterInlinePanelsClose() {
    if (!this.pausedByPanelOpen || !this.wasPlayingBeforePanelOpen)
      return;
    this.pausedByPanelOpen = false;
    this.wasPlayingBeforePanelOpen = false;
    this.engine.play();
    updatePlayPauseButtons(this.dom, true);
    this.setContextScrollEnabled(false);
  }
  closeInlinePanels() {
    const wasAnyOpen = this.isAnyInlinePanelOpen();
    if (!wasAnyOpen)
      return;
    this.state.set("showingControls", false);
    this.settingsEl.toggleClass(CSS_CLASSES.hidden, true);
    this.resumePlaybackAfterInlinePanelsClose();
  }
  setupOutsideClickToClosePanels() {
    this.registerDomEvent(
      document,
      "pointerdown",
      (evt) => {
        var _a, _b, _c, _d;
        if (!this.isAnyInlinePanelOpen())
          return;
        const target = evt.target;
        if (!target)
          return;
        const clickedInsidePanels = (_b = (_a = this.settingsEl) == null ? void 0 : _a.contains(target)) != null ? _b : false;
        const clickedOnToggleBar = (_d = (_c = this.toggleBar) == null ? void 0 : _c.contains(target)) != null ? _d : false;
        if (clickedInsidePanels || clickedOnToggleBar)
          return;
        const controlsOpen = this.settingsEl && !this.settingsEl.hasClass(CSS_CLASSES.hidden);
        if (!controlsOpen)
          return;
        this.ignoreNextDisplayToggleClick = true;
        this.closeInlinePanels();
      },
      true
    );
  }
  suppressAutoLoad(ms = 250) {
    this.suppressAutoLoadUntil = Date.now() + ms;
  }
  isAutoLoadSuppressed() {
    return Date.now() < this.suppressAutoLoadUntil;
  }
  defocusInteractiveElements() {
    const active = document.activeElement;
    if (active && this.modalEl.contains(active) && active.tagName.toLowerCase() === "button") {
      active.blur();
    }
    this.modalEl.focus();
  }
  /**
   * Toggles the visibility of context before/after current word
   */
  toggleContextDisplay() {
    const hasText = this.engine.getTotalWords() > 0;
    const shouldHide = !this.getActiveShowContext() || !hasText || this.suppressContextUntilPlay;
    if (this.contextBeforeEl)
      this.contextBeforeEl.toggleClass(CSS_CLASSES.hidden, shouldHide);
    if (this.contextAfterEl)
      this.contextAfterEl.toggleClass(CSS_CLASSES.hidden, shouldHide);
  }
  /**
   * Toggle breadcrumb visibility
   */
  toggleBreadcrumbDisplay() {
    const shouldHide = !this.getActiveShowBreadcrumb();
    if (this.breadcrumbEl) {
      this.breadcrumbEl.toggleClass(CSS_CLASSES.hidden, shouldHide);
    }
  }
  // ============================================================================
  // SECTION 5: AUTO-LOAD SYSTEM
  // ============================================================================
  /**
   * Sets up automatic text loading from editor
   *
   * Registers event handlers for:
   * - file-open: Load text when opening a file
   * - active-leaf-change: Load text when switching files
   * - mouseup: Check for selection/cursor changes
   * - keyup: Check for navigation/selection keys
   *
   * Actual tracking logic is encapsulated in AutoLoadManager
   */
  setupAutoLoad() {
    this.registerEvent(
      this.app.workspace,
      this.app.workspace.on("file-open", (file) => {
        if (this.isAutoLoadSuppressed())
          return;
        if (!file)
          return;
        this.autoLoadManager.resetForNewFile(file.path);
        this.autoLoadManager.loadFromEditor(TIMING.autoLoadDelay);
      })
    );
    this.registerEvent(
      this.app.workspace,
      this.app.workspace.on("active-leaf-change", () => {
        if (this.isAutoLoadSuppressed())
          return;
        if (!this.mainContainerEl || !this.mainContainerEl.isShown())
          return;
        const currentFile = this.app.workspace.getActiveFile();
        if (currentFile && this.autoLoadManager.hasFileChanged(currentFile.path)) {
          this.autoLoadManager.resetForNewFile(currentFile.path);
          this.autoLoadManager.loadFromEditor(TIMING.autoLoadDelayShort);
        }
      })
    );
    this.registerDomEvent(document, "mouseup", (evt) => {
      if (this.isAutoLoadSuppressed())
        return;
      const target = evt.target;
      if (target && this.modalEl.contains(target))
        return;
      this.timeoutManager.setTimeout(() => {
        if (this.mainContainerEl.isShown() && !this.isAutoLoadSuppressed()) {
          this.autoLoadManager.checkSelectionOrCursor();
        }
      }, TIMING.autoLoadDelayVeryShort);
    });
    this.registerDomEvent(document, "keyup", (evt) => {
      if (this.isAutoLoadSuppressed())
        return;
      if (this.engine.getIsPlaying())
        return;
      const active = document.activeElement;
      if (active && this.modalEl.contains(active))
        return;
      if (isNavigationKey(evt) || isSelectionKey(evt)) {
        this.timeoutManager.setTimeout(() => {
          if (this.mainContainerEl.isShown() && !this.isAutoLoadSuppressed() && !this.engine.getIsPlaying()) {
            this.autoLoadManager.checkSelectionOrCursor();
          }
        }, TIMING.autoLoadDelayVeryShort);
      }
    });
  }
  // ============================================================================
  // SECTION 6: HOTKEYS & KEYBOARD
  // ============================================================================
  /**
   * Sets up keyboard shortcuts for playback control
   */
  setupHotkeys() {
    if (this.keydownHandler)
      return;
    this.keydownHandler = (e) => this.handleKeyPress(e);
    this.registerDomEvent(document, "keydown", this.keydownHandler);
  }
  /**
   * Handles keyboard shortcuts
   *
   * Shortcuts:
   * - C: Toggle controls (when not playing)
   * - Shift+Space: Play/Pause
   * - Arrow keys: Rewind/Forward, WPM adjustment
   * - Escape: Stop reading
   *
   * @param e - Keyboard event
   */
  handleKeyPress(e) {
    var _a, _b;
    if (!this.mainContainerEl.isShown())
      return;
    const tag = ((_b = (_a = document.activeElement) == null ? void 0 : _a.tagName) != null ? _b : "").toLowerCase();
    if (tag === "input" || tag === "textarea")
      return;
    const isCmd = e.ctrlKey || e.metaKey;
    if (isCmd && e.key === "ArrowLeft") {
      e.preventDefault();
      this.suppressAutoLoad();
      this.engine.jumpToStart();
      return;
    }
    if (isCmd && e.key === "ArrowRight") {
      e.preventDefault();
      this.suppressAutoLoad();
      this.engine.jumpToEnd();
      return;
    }
    if (!e.shiftKey && !e.altKey && !isCmd && e.key === "ArrowUp") {
      e.preventDefault();
      this.suppressAutoLoad();
      this.jumpHeading("up");
      return;
    }
    if (!e.shiftKey && !e.altKey && !isCmd && e.key === "ArrowDown") {
      e.preventDefault();
      this.suppressAutoLoad();
      this.jumpHeading("down");
      return;
    }
    if (!isCmd && e.key.toLowerCase() === "s") {
      e.preventDefault();
      this.suppressAutoLoad();
      this.togglePanel("controls");
      return;
    }
    this.hotkeyHandler.handleKeyPress(e);
    if (e.defaultPrevented) {
      this.suppressAutoLoad();
    }
  }
  /**
   * Toggles play/pause state
   * Updates UI buttons accordingly
   */
  togglePlay() {
    if (this.isAnyInlinePanelOpen()) {
      this.pausedByPanelOpen = false;
      this.wasPlayingBeforePanelOpen = false;
    }
    if (this.engine.getIsPlaying()) {
      this.engine.pause();
      updatePlayPauseButtons(this.dom, false);
      this.setContextScrollEnabled(true);
      if (this.getActiveShowContext()) {
        this.scheduleContextUpdate(this.getContextAnchorIndex());
      }
    } else {
      if (this.state.get("startTime") === 0) {
        this.state.set("startTime", Date.now());
      }
      this.engine.play();
      updatePlayPauseButtons(this.dom, true);
      if (this.suppressContextUntilPlay) {
        this.suppressContextUntilPlay = false;
        this.toggleContextDisplay();
        if (this.getActiveShowContext()) {
          this.scheduleContextUpdate(this.getContextAnchorIndex());
        }
      }
      this.setContextScrollEnabled(false);
    }
    this.defocusInteractiveElements();
  }
  getIndexFromProgressClientX(clientX) {
    const bar = this.progressBarEl;
    if (!bar)
      return null;
    const rect = bar.getBoundingClientRect();
    const x = Math.max(0, Math.min(rect.width, clientX - rect.left));
    const ratio = rect.width > 0 ? x / rect.width : 0;
    const total = this.engine.getTotalWords();
    if (total <= 0)
      return null;
    return Math.min(total - 1, Math.max(0, Math.floor(ratio * (total - 1))));
  }
  buildProgressHoverTooltip(targetIndex) {
    var _a, _b;
    const totalWords = this.engine.getTotalWords();
    const totalSec = this.engine.getVirtualTotalSeconds();
    const atSec = this.engine.getVirtualElapsedSecondsAtIndex(targetIndex);
    const ctx = this.engine.getCurrentHeadingContext(targetIndex);
    const headingText = ((_b = (_a = ctx == null ? void 0 : ctx.breadcrumb) == null ? void 0 : _a.length) != null ? _b : 0) > 0 ? ctx.breadcrumb.map((h) => h.text.replace(/^\[CALLOUT:[\w-]+\]/, "").trim()).filter(Boolean).join(" \u203A ") : "Top";
    const parts = [
      headingText,
      totalWords > 0 ? `${targetIndex + 1}/${totalWords} words` : `0/0 words`
    ];
    if (totalSec > 0) {
      parts.push(
        `${this.formatTime(atSec)}/${this.formatTime(totalSec)}`
      );
    }
    return parts.join(" \u2022 ");
  }
  updateProgressTooltipForClientX(clientX) {
    const idx = this.getIndexFromProgressClientX(clientX);
    if (idx === null || !this.progressBarEl)
      return;
    if (this.progressBarLastTooltipIndex === idx)
      return;
    this.progressBarLastTooltipIndex = idx;
    this.progressBarEl.setAttr("aria-label", this.buildProgressHoverTooltip(idx));
  }
  restoreProgressTooltipToPercent() {
    if (!this.progressBarEl)
      return;
    const total = this.progressBarEl.max || (this.engine.getTotalWords() || 1);
    const current = this.progressBarEl.value || Math.min(total, this.getContextAnchorIndex() + 1);
    const percent = Math.min(100, current / total * 100);
    this.progressBarEl.setAttr("aria-label", `${Math.round(percent)} %`);
  }
  updateProgressBar(chunk) {
    if (!this.progressBarEl || !this.settings.showProgress)
      return;
    const total = this.engine.getTotalWords() || 1;
    const current = Math.min(total, chunk.index + 1);
    this.progressBarEl.max = total;
    this.progressBarEl.value = current;
    const percent = Math.min(100, current / total * 100);
    if (!this.isProgressBarHovering) {
      this.progressBarEl.setAttr("aria-label", `${Math.round(percent)} %`);
    }
    this.updateBottomProgressInfo(chunk.index);
  }
  updateBottomProgressInfo(wordIndex) {
    var _a, _b;
    if (this.engine.getTotalWords() === 0) {
      (_a = this.progressInfoLeftEl) == null ? void 0 : _a.setText("");
      (_b = this.progressInfoRightEl) == null ? void 0 : _b.setText("");
      return;
    }
    if (!this.progressInfoLeftEl || !this.progressInfoRightEl)
      return;
    const total = Math.max(1, this.engine.getTotalWords());
    const idx0 = typeof wordIndex === "number" ? wordIndex : this.getContextAnchorIndex();
    const at = Math.min(total, Math.max(1, idx0 + 1));
    this.progressInfoLeftEl.setText(`${at}/${total}`);
    const wpm = this.engine.getWpm();
    const totalSec = this.engine.getVirtualTotalSeconds();
    const atSec = this.engine.getVirtualElapsedSecondsAtCurrentIndex();
    this.progressInfoRightEl.setText(
      `${this.formatTime(atSec)}/${this.formatTime(totalSec)}`
    );
  }
  renderContextTokens(tokens) {
    const isBreak = (t) => t === "\n" || t === "\xA7\xA7LINEBREAK\xA7\xA7";
    let out = "";
    let atLineStart = true;
    for (const raw of tokens) {
      if (isBreak(raw)) {
        out = out.replace(/[ \t]+$/g, "");
        out += "\n";
        atLineStart = true;
        continue;
      }
      const t = raw.replace(/^\[H\d\]/, "").replace(/^\[CALLOUT:[\w-]+\]/, "");
      if (!t)
        continue;
      if (!atLineStart)
        out += " ";
      out += t;
      atLineStart = false;
    }
    out = out.replace(/ +([,.;:!?])/g, "$1");
    out = out.replace(/\n +/g, "\n");
    return out.trimEnd();
  }
  getNavigableHeadings() {
    return this.engine.getHeadings().filter((h) => h.level >= 1);
  }
  getActiveShowContext() {
    return this.isMobileUI() ? this.settings.mobileShowContext : this.settings.showContext;
  }
  setActiveShowContext(v) {
    if (this.isMobileUI())
      this.settings.mobileShowContext = v;
    else
      this.settings.showContext = v;
    this.requestSettingsSave();
  }
  getActiveShowBreadcrumb() {
    return this.isMobileUI() ? this.settings.mobileShowBreadcrumb : this.settings.showBreadcrumb;
  }
  setActiveShowBreadcrumb(v) {
    if (this.isMobileUI())
      this.settings.mobileShowBreadcrumb = v;
    else
      this.settings.showBreadcrumb = v;
    this.requestSettingsSave();
  }
  getActiveContextLines() {
    return this.isMobileUI() ? this.settings.mobileContextLines : this.settings.contextLines;
  }
  setActiveContextLines(v) {
    if (this.isMobileUI())
      this.settings.mobileContextLines = v;
    else
      this.settings.contextLines = v;
  }
  getActiveContextFontSize() {
    return this.isMobileUI() ? this.settings.mobileContextFontSize : this.settings.contextFontSize;
  }
  setActiveContextFontSize(v) {
    if (this.isMobileUI())
      this.settings.mobileContextFontSize = v;
    else
      this.settings.contextFontSize = v;
  }
  jumpHeading(dir) {
    var _a, _b;
    const headings = this.getNavigableHeadings();
    if (headings.length === 0)
      return;
    const now = Date.now();
    const withinWindow = this.headingNav.dir === dir && now - this.headingNav.lastTime <= _DashReaderView.HEADING_NAV_WINDOW_MS;
    const curWord = this.getContextAnchorIndex();
    let curHeadingIdx = -1;
    for (let i = headings.length - 1; i >= 0; i--) {
      if (headings[i].wordIndex <= curWord) {
        curHeadingIdx = i;
        break;
      }
    }
    if (!withinWindow || this.headingNav.cursor === null) {
      if (dir === "up") {
        let target = curHeadingIdx;
        if (target >= 0 && headings[target].wordIndex === curWord)
          target -= 1;
        this.headingNav.cursor = target;
      } else {
        this.headingNav.cursor = curHeadingIdx + 1;
      }
    } else {
      this.headingNav.cursor = ((_a = this.headingNav.cursor) != null ? _a : curHeadingIdx) + (dir === "up" ? -1 : 1);
    }
    this.headingNav.dir = dir;
    this.headingNav.lastTime = now;
    const idx = (_b = this.headingNav.cursor) != null ? _b : -1;
    if (dir === "up") {
      if (idx < 0) {
        this.engine.jumpToStart();
        return;
      }
    } else {
      if (idx >= headings.length) {
        this.engine.jumpToEnd();
        return;
      }
    }
    this.engine.jumpToIndex(headings[idx].wordIndex);
  }
  applyContextLayout() {
    if (!this.contextBeforeEl || !this.contextAfterEl)
      return;
    const fontPx = this.getActiveContextFontSize();
    const fullLines = Math.max(0, this.getActiveContextLines());
    const totalLinesPerPanel = fullLines + 1;
    const lineHeightPx = Math.round(fontPx * 1.6);
    const panelHeightPx = totalLinesPerPanel * lineHeightPx;
    for (const el of [this.contextBeforeEl, this.contextAfterEl]) {
      el.style.fontSize = `${fontPx}px`;
      el.style.lineHeight = `${lineHeightPx}px`;
      el.style.height = `${panelHeightPx}px`;
      el.style.minHeight = `${panelHeightPx}px`;
      el.style.maxHeight = `${panelHeightPx}px`;
      el.style.whiteSpace = "pre-wrap";
      el.style.overflowWrap = "anywhere";
      el.style.wordBreak = "break-word";
      el.style.wordBreak = "normal";
      el.style.overflowWrap = "normal";
      el.style.overflowX = "hidden";
      el.style.textAlign = "left";
    }
  }
  // ============================================================================
  // SECTION 7: READING ENGINE CALLBACKS
  // ============================================================================
  /**
   * Called by engine when a new word is displayed
   * Updates the UI with the current word, context, progress, and stats
   *
   * @param chunk - Word chunk with text, index, delay info
   */
  onWordChange(chunk) {
    this.lastDisplayedIndex = chunk.index;
    const headingMatch = chunk.text.match(/^\[H(\d)\]/);
    const calloutMatch = chunk.text.match(/^\[CALLOUT:([\w-]+)\]/);
    let displayText = chunk.text;
    let headingLevel = 0;
    let showSeparator = false;
    let calloutType;
    if (headingMatch) {
      headingLevel = parseInt(headingMatch[1]);
      displayText = chunk.text.replace(/^\[H\d\]/, "");
      showSeparator = false;
    } else if (calloutMatch) {
      calloutType = calloutMatch[1];
      displayText = chunk.text.replace(/^\[CALLOUT:[\w-]+\]/, "");
      showSeparator = false;
    }
    this.wordDisplay.displayWord(displayText, headingLevel, false, calloutType);
    if (chunk.headingContext && this.breadcrumbManager) {
      if (this.breadcrumbManager.hasHeadingContextChanged(chunk.headingContext)) {
        this.breadcrumbManager.updateBreadcrumb(chunk.headingContext);
      }
    }
    if (this.getActiveShowContext() && this.contextBeforeEl && this.contextAfterEl) {
      this.scheduleContextUpdate(chunk.index);
    }
    this.updateProgressBar(chunk);
    this.requestSettingsSave();
  }
  // ============================================================================
  // SECTION 8: TEXT LOADING
  // ============================================================================
  /**
   * Parses markdown and calculates start position from cursor
   *
   * @param text - Raw markdown text
   * @param cursorPosition - Optional cursor position in raw text
   * @returns Object with plainText and wordIndex
   */
  parseAndCalculateStartPosition(text, cursorPosition) {
    const plainText = MarkdownParser.parseToPlainText(text);
    let wordIndex;
    if (cursorPosition !== void 0) {
      const textUpToCursor = text.substring(0, cursorPosition);
      const parsedUpToCursor = MarkdownParser.parseToPlainText(textUpToCursor);
      const cleanedUpToCursor = parsedUpToCursor.replace(/\n+/g, " \xA7\xA7LINEBREAK\xA7\xA7 ").replace(/[ \t]+/g, " ").trim();
      const tokensBeforeCursor = cleanedUpToCursor.split(/\s+/).filter(Boolean);
      wordIndex = tokensBeforeCursor.length;
    }
    return { plainText, wordIndex };
  }
  /**
   * Updates stats display and word display with ready message
   *
   * @param wordIndex - Starting word index (if resuming from cursor)
   * @param source - Optional source information (filename, line number)
   */
  updateStatsDisplay(wordIndex, source) {
    const startDelaySec = this.settings.autoStart ? Math.max(0, Math.round(this.settings.autoStartDelay)) : 0;
    const estimatedDurationSec = this.engine.getVirtualRemainingSeconds() + startDelaySec;
    const durationText = this.formatTime(estimatedDurationSec);
    this.wordDisplay.displayReadyMessage(
      this.engine.getRemainingWords(),
      this.engine.getTotalWords(),
      wordIndex,
      durationText,
      source == null ? void 0 : source.fileName,
      source == null ? void 0 : source.lineNumber
    );
  }
  /**
   * Builds and displays initial breadcrumb based on starting position
   *
   * @param wordIndex - Starting word index (0 if starting from beginning)
   */
  buildInitialBreadcrumb(wordIndex) {
    const context = this.engine.getCurrentHeadingContext(wordIndex);
    if (context.breadcrumb.length > 0) {
      this.breadcrumbManager.updateBreadcrumb(context);
    }
  }
  /**
   * Handles auto-start functionality if enabled in settings
   * Starts reading after the configured delay
   */
  handleAutoStart() {
    if (!this.settings.autoStart)
      return;
    this.timeoutManager.setTimeout(() => {
      this.suppressContextUntilPlay = false;
      this.toggleContextDisplay();
      this.engine.play();
      if (this.getActiveShowContext())
        this.scheduleContextUpdate(this.getContextAnchorIndex());
      updatePlayPauseButtons(this.dom, true);
      this.state.set("startTime", Date.now());
      this.setContextScrollEnabled(false);
    }, this.settings.autoStartDelay * 1e3);
  }
  /**
   * Loads text for reading
   *
   * Process:
   * 1. Stop current reading if playing
   * 2. Parse markdown to plain text
   * 3. Calculate word index from cursor position (if provided)
   * 4. Validate text length
   * 5. Load into engine
   * 6. Update UI with ready message
   * 7. Auto-start if enabled
   *
   * @param text - Text to load (raw markdown)
   * @param source - Optional source information (filename, line, cursor position)
   */
  loadText(text, source) {
    if (!this.isInitialized) {
      this.pendingLoad = { text, source };
      this.skipInitialAutoLoad = true;
      return;
    }
    if (!source || source.cursorPosition === void 0) {
      this.suppressAutoLoad(1e3);
      this.autoLoadManager.syncStateToEditor();
    }
    this.engine.stop();
    updatePlayPauseButtons(this.dom, false);
    this.setContextScrollEnabled(true);
    this.breadcrumbManager.reset();
    const { plainText, wordIndex: wordIndexFromCursor } = this.parseAndCalculateStartPosition(
      text,
      source == null ? void 0 : source.cursorPosition
    );
    if (!plainText || plainText.trim().length < TEXT_LIMITS.minParsedLength) {
      return;
    }
    this.engine.setText(plainText, void 0, wordIndexFromCursor);
    this.state.update({ wordsRead: 0, startTime: 0 });
    this.sessionStartIndex = this.getContextAnchorIndex();
    this.sessionTotalTokens = Math.max(1, this.engine.getTotalWords() - this.sessionStartIndex);
    this.sessionTotalDurationSec = this.engine.getEstimatedDuration();
    const welcomeMsg = this.wordEl.querySelector(`.${CSS_CLASSES.welcome}`);
    if (welcomeMsg) {
      welcomeMsg.remove();
    }
    if (this.wordDisplay)
      this.wordDisplay.clear();
    else
      this.wordEl.empty();
    this.updateStatsDisplay(wordIndexFromCursor, source);
    this.buildInitialBreadcrumb(wordIndexFromCursor != null ? wordIndexFromCursor : 0);
    this.toggleContextDisplay();
    if (this.getActiveShowContext()) {
      this.scheduleContextUpdate(this.getContextAnchorIndex());
    }
    this.handleAutoStart();
  }
  // ============================================================================
  // SECTION 9: SETTINGS & LIFECYCLE
  // ============================================================================
  /**
   * Updates settings from plugin settings tab
   * Called when user changes settings in main settings panel
   *
   * @param settings - New settings
   */
  togglePlayPause() {
    this.togglePlay();
  }
  requestSkipInitialAutoLoadOnce() {
    this.skipInitialAutoLoad = true;
  }
  updateSettings(settings) {
    var _a, _b, _c;
    this.settings = settings;
    this.engine.updateSettings(settings);
    this.engine.setUseMobileProfile(this.isMobileUI());
    this.applyContextLayout();
    this.applyAppearanceCssVars();
    if (this.mainContainerEl) {
      this.mainContainerEl.style.fontFamily = settings.fontFamily || "inherit";
    }
    if (this.wordEl) {
      this.wordEl.style.setProperty("font-size", `${this.getActiveFontSize()}px`, "important");
      (_a = this.wordDisplay) == null ? void 0 : _a.setBaseFontSize(this.getActiveFontSize());
      (_b = this.wordDisplay) == null ? void 0 : _b.setChunkSize(this.engine.getChunkSize());
      this.wordEl.style.fontFamily = settings.fontFamily;
    }
    if (this.progressBarEl) {
      this.progressBarEl.style.display = settings.showProgress ? "" : "none";
    }
    (_c = this.wordDisplay) == null ? void 0 : _c.updateSettings(this.settings);
    this.toggleContextDisplay();
    this.toggleBreadcrumbDisplay();
  }
};
var DashReaderView = _DashReaderView;
DashReaderView.HEADING_NAV_WINDOW_MS = 700;

// src/settings.ts
var import_obsidian6 = require("obsidian");
var DashReaderSettingTab = class extends import_obsidian6.PluginSettingTab {
  constructor(app, plugin) {
    super(app, plugin);
    this.plugin = plugin;
  }
  /**
   * Helper method to create a slider with an editable numeric display
   */
  createSliderWithInput(setting, min, max, step, value, unit = "", onChange) {
    const inputEl = setting.controlEl.createEl("input", {
      type: "text",
      value: value.toString(),
      cls: "dashreader-slider-input"
    });
    if (unit) {
      setting.controlEl.createSpan({
        text: unit,
        cls: "dashreader-slider-unit"
      });
    }
    setting.addSlider((slider) => slider.setLimits(min, max, step).setValue(value).setDynamicTooltip().onChange(async (newValue) => {
      inputEl.value = newValue.toString();
      await onChange(newValue);
    }));
    inputEl.addEventListener("change", () => void (async () => {
      let newValue = parseFloat(inputEl.value);
      if (isNaN(newValue)) {
        newValue = value;
      } else {
        newValue = Math.max(min, Math.min(max, newValue));
        newValue = Math.round(newValue / step) * step;
      }
      inputEl.value = newValue.toString();
      const sliderEl = setting.controlEl.querySelector('input[type="range"]');
      if (sliderEl) {
        sliderEl.value = newValue.toString();
      }
      await onChange(newValue);
    })());
  }
  display() {
    const { containerEl } = this;
    containerEl.empty();
    new import_obsidian6.Setting(containerEl).setName("Dashreader Settings").setHeading();
    new import_obsidian6.Setting(containerEl).setName("Display Options").setHeading();
    new import_obsidian6.Setting(containerEl).setName("Show Breadcrumb").setDesc("Display breadcrumb navigation at the top.").addToggle((toggle) => toggle.setValue(this.plugin.settings.showBreadcrumb).onChange(async (value) => {
      this.plugin.settings.showBreadcrumb = value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian6.Setting(containerEl).setName("Show Progress Bar").setDesc("Display reading progress bar.").addToggle((toggle) => toggle.setValue(this.plugin.settings.showProgress).onChange(async (value) => {
      this.plugin.settings.showProgress = value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian6.Setting(containerEl).setName("Reading Settings").setHeading();
    const wpmSetting = new import_obsidian6.Setting(containerEl).setName("Words per Minute").setDesc("Reading speed (50-5000).");
    this.createSliderWithInput(
      wpmSetting,
      50,
      5e3,
      25,
      this.plugin.settings.wpm,
      "",
      async (value) => {
        this.plugin.settings.wpm = value;
        await this.plugin.saveSettings();
      }
    );
    const fontSizeSetting = new import_obsidian6.Setting(containerEl).setName("Font Size (Desktop)").setDesc("Font size in pixels (20-120px).");
    this.createSliderWithInput(
      fontSizeSetting,
      20,
      120,
      4,
      this.plugin.settings.fontSize,
      "px",
      async (value) => {
        this.plugin.settings.fontSize = value;
        await this.plugin.saveSettings();
      }
    );
    const chunkSetting = new import_obsidian6.Setting(containerEl).setName("Words at a Time (Desktop)").setDesc("Number of words displayed simultaneously for desktop profile (1\u20135).");
    this.createSliderWithInput(
      chunkSetting,
      1,
      5,
      1,
      this.plugin.settings.chunkSize,
      "",
      async (value) => {
        this.plugin.settings.chunkSize = value;
        await this.plugin.saveSettings();
      }
    );
    const mobileFontSizeSetting = new import_obsidian6.Setting(containerEl).setName("Font Size (Mobile)").setDesc("Font size in pixels used on mobile/touch devices (12-120px).");
    this.createSliderWithInput(
      mobileFontSizeSetting,
      12,
      120,
      4,
      this.plugin.settings.mobileFontSize,
      "px",
      async (value) => {
        this.plugin.settings.mobileFontSize = value;
        await this.plugin.saveSettings();
      }
    );
    const mobileChunkSetting = new import_obsidian6.Setting(containerEl).setName("Words at a Time (Mobile)").setDesc("Number of words displayed simultaneously for mobile/touch profile (1\u20135).");
    this.createSliderWithInput(
      mobileChunkSetting,
      1,
      5,
      1,
      this.plugin.settings.mobileChunkSize,
      "",
      async (value) => {
        this.plugin.settings.mobileChunkSize = value;
        await this.plugin.saveSettings();
      }
    );
    const minTokenFontSizeSetting = new import_obsidian6.Setting(containerEl).setName("Minimum Token Font Size").setDesc("Lowest font size used when a single long token is shrunk to fit (8\u201348px).");
    this.createSliderWithInput(
      minTokenFontSizeSetting,
      8,
      48,
      1,
      this.plugin.settings.minTokenFontSize,
      "px",
      async (value) => {
        this.plugin.settings.minTokenFontSize = value;
        await this.plugin.saveSettings();
      }
    );
    new import_obsidian6.Setting(containerEl).setName("Font Family").setDesc("Font family for text display.").addDropdown((dropdown) => dropdown.addOption("inherit", "Default").addOption("literata", "Literata").addOption("monospace", "Monospace").addOption("serif", "Serif").addOption("sans-serif", "Sans-serif").setValue(this.plugin.settings.fontFamily).onChange(async (value) => {
      this.plugin.settings.fontFamily = value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian6.Setting(containerEl).setName("Reading Enhancements").setHeading();
    new import_obsidian6.Setting(containerEl).setName("Slow Start").setDesc("Gradually increase speed over first 5 words for comfortable start.").addToggle((toggle) => toggle.setValue(this.plugin.settings.enableSlowStart).onChange(async (value) => {
      this.plugin.settings.enableSlowStart = value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian6.Setting(containerEl).setName("Enable Acceleration").setDesc("Gradually increase reading speed over time.").addToggle((toggle) => toggle.setValue(this.plugin.settings.enableAcceleration).onChange(async (value) => {
      this.plugin.settings.enableAcceleration = value;
      await this.plugin.saveSettings();
    }));
    const accelDurationSetting = new import_obsidian6.Setting(containerEl).setName("Acceleration Duration").setDesc("Duration to reach target speed (seconds).");
    this.createSliderWithInput(
      accelDurationSetting,
      10,
      120,
      5,
      this.plugin.settings.accelerationDuration,
      "s",
      async (value) => {
        this.plugin.settings.accelerationDuration = value;
        await this.plugin.saveSettings();
      }
    );
    const accelTargetSetting = new import_obsidian6.Setting(containerEl).setName("Target WPM").setDesc("Target reading speed to reach (50-5000).");
    this.createSliderWithInput(
      accelTargetSetting,
      50,
      5e3,
      25,
      this.plugin.settings.accelerationTargetWpm,
      "",
      async (value) => {
        this.plugin.settings.accelerationTargetWpm = value;
        await this.plugin.saveSettings();
      }
    );
    new import_obsidian6.Setting(containerEl).setName("Appearance").setHeading();
    new import_obsidian6.Setting(containerEl).setName("Highlight Color").setDesc("Leave blank to use theme/CSS (This setting now maps to --dashreader-highlight-color.).").addText((text) => text.setPlaceholder("theme").setValue(this.plugin.settings.highlightColor).onChange(async (value) => {
      this.plugin.settings.highlightColor = value.trim();
      await this.plugin.saveSettings();
    }));
    new import_obsidian6.Setting(containerEl).setName("Font Color").setDesc("Leave blank to use theme/CSS (Maps to --dashreader-font-color.).").addText((text) => text.setPlaceholder("theme").setValue(this.plugin.settings.fontColor).onChange(async (value) => {
      this.plugin.settings.fontColor = value.trim();
      await this.plugin.saveSettings();
    }));
    new import_obsidian6.Setting(containerEl).setName("Background Color").setDesc("Leave blank to use theme/CSS (Maps to --dashreader-background-color.).").addText((text) => text.setPlaceholder("theme").setValue(this.plugin.settings.backgroundColor).onChange(async (value) => {
      this.plugin.settings.backgroundColor = value.trim();
      await this.plugin.saveSettings();
    }));
    new import_obsidian6.Setting(containerEl).setName("Context Display").setHeading();
    new import_obsidian6.Setting(containerEl).setName("Show Context (Desktop)").setDesc("Display line-based context around the current phrase.").addToggle((toggle) => toggle.setValue(this.plugin.settings.showContext).onChange(async (value) => {
      this.plugin.settings.showContext = value;
      await this.plugin.saveSettings();
    }));
    const contextLinesSetting = new import_obsidian6.Setting(containerEl).setName("Context Lines (Desktop)").setDesc("Extra full lines above and below the anchor line (0\u201310). 0 = anchor only.");
    this.createSliderWithInput(
      contextLinesSetting,
      0,
      10,
      1,
      this.plugin.settings.contextLines,
      "",
      async (value) => {
        this.plugin.settings.contextLines = value;
        await this.plugin.saveSettings();
      }
    );
    const contextFontSizeSetting = new import_obsidian6.Setting(containerEl).setName("Context Font Size (Desktop)").setDesc("Font size for context panels (10\u201332px).");
    this.createSliderWithInput(
      contextFontSizeSetting,
      10,
      32,
      1,
      this.plugin.settings.contextFontSize,
      "px",
      async (value) => {
        this.plugin.settings.contextFontSize = value;
        await this.plugin.saveSettings();
      }
    );
    new import_obsidian6.Setting(containerEl).setName("Show Context (Mobile)").setDesc("Display line-based context on mobile profile.").addToggle((toggle) => toggle.setValue(this.plugin.settings.mobileShowContext).onChange(async (value) => {
      this.plugin.settings.mobileShowContext = value;
      await this.plugin.saveSettings();
    }));
    const mobileContextLinesSetting = new import_obsidian6.Setting(containerEl).setName("Context Lines (Mobile)").setDesc("Extra full lines above and below the anchor line on mobile (0\u201310).");
    this.createSliderWithInput(
      mobileContextLinesSetting,
      0,
      10,
      1,
      this.plugin.settings.mobileContextLines,
      "",
      async (value) => {
        this.plugin.settings.mobileContextLines = value;
        await this.plugin.saveSettings();
      }
    );
    const mobileContextFontSizeSetting = new import_obsidian6.Setting(containerEl).setName("Context Font Size (Mobile)").setDesc("Font size for context panels on mobile (10\u201332px).");
    this.createSliderWithInput(
      mobileContextFontSizeSetting,
      10,
      32,
      1,
      this.plugin.settings.mobileContextFontSize,
      "px",
      async (value) => {
        this.plugin.settings.mobileContextFontSize = value;
        await this.plugin.saveSettings();
      }
    );
    new import_obsidian6.Setting(containerEl).setName("Micropause").setHeading();
    new import_obsidian6.Setting(containerEl).setName("Enable Micropause").setDesc("Automatic pauses based on punctuation and word length.").addToggle((toggle) => toggle.setValue(this.plugin.settings.enableMicropause).onChange(async (value) => {
      this.plugin.settings.enableMicropause = value;
      await this.plugin.saveSettings();
    }));
    const punctuationSetting = new import_obsidian6.Setting(containerEl).setName("Sentence-ending Punctuation Pause").setDesc("Pause multiplier for .,!? (1.0-3.0).");
    this.createSliderWithInput(
      punctuationSetting,
      1,
      3,
      0.1,
      this.plugin.settings.micropausePunctuation,
      "x",
      async (value) => {
        this.plugin.settings.micropausePunctuation = value;
        await this.plugin.saveSettings();
      }
    );
    const otherPunctuationSetting = new import_obsidian6.Setting(containerEl).setName("Other Punctuation Pause").setDesc("Pause multiplier for ;:, (1.0-3.0).");
    this.createSliderWithInput(
      otherPunctuationSetting,
      1,
      3,
      0.1,
      this.plugin.settings.micropauseOtherPunctuation,
      "x",
      async (value) => {
        this.plugin.settings.micropauseOtherPunctuation = value;
        await this.plugin.saveSettings();
      }
    );
    const longWordsSetting = new import_obsidian6.Setting(containerEl).setName("Long Words Pause").setDesc("Pause multiplier for long words >8 chars (1.0-2.0).");
    this.createSliderWithInput(
      longWordsSetting,
      1,
      2,
      0.1,
      this.plugin.settings.micropauseLongWords,
      "x",
      async (value) => {
        this.plugin.settings.micropauseLongWords = value;
        await this.plugin.saveSettings();
      }
    );
    const paragraphSetting = new import_obsidian6.Setting(containerEl).setName("Paragraph Pause").setDesc("Pause multiplier for paragraph breaks (1.0-5.0).");
    this.createSliderWithInput(
      paragraphSetting,
      1,
      5,
      0.1,
      this.plugin.settings.micropauseParagraph,
      "x",
      async (value) => {
        this.plugin.settings.micropauseParagraph = value;
        await this.plugin.saveSettings();
      }
    );
    const numbersSetting = new import_obsidian6.Setting(containerEl).setName("Numbers Pause").setDesc("Pause multiplier for numbers and dates (1.0-3.0).");
    this.createSliderWithInput(
      numbersSetting,
      1,
      3,
      0.1,
      this.plugin.settings.micropauseNumbers,
      "x",
      async (value) => {
        this.plugin.settings.micropauseNumbers = value;
        await this.plugin.saveSettings();
      }
    );
    const sectionMarkersSetting = new import_obsidian6.Setting(containerEl).setName("Section Markers Pause").setDesc("Pause multiplier for 1., i., a., etc. (1.0-3.0).");
    this.createSliderWithInput(
      sectionMarkersSetting,
      1,
      3,
      0.1,
      this.plugin.settings.micropauseSectionMarkers,
      "x",
      async (value) => {
        this.plugin.settings.micropauseSectionMarkers = value;
        await this.plugin.saveSettings();
      }
    );
    const listBulletsSetting = new import_obsidian6.Setting(containerEl).setName("List Bullets Pause").setDesc("Pause multiplier for -, *, +, \u2022 (1.0-3.0).");
    this.createSliderWithInput(
      listBulletsSetting,
      1,
      3,
      0.1,
      this.plugin.settings.micropauseListBullets,
      "x",
      async (value) => {
        this.plugin.settings.micropauseListBullets = value;
        await this.plugin.saveSettings();
      }
    );
    const calloutsSetting = new import_obsidian6.Setting(containerEl).setName("Callouts Pause").setDesc("Pause multiplier for Obsidian callouts (1.0-3.0).");
    this.createSliderWithInput(
      calloutsSetting,
      1,
      3,
      0.1,
      this.plugin.settings.micropauseCallouts,
      "x",
      async (value) => {
        this.plugin.settings.micropauseCallouts = value;
        await this.plugin.saveSettings();
      }
    );
    new import_obsidian6.Setting(containerEl).setName("Auto-start").setHeading();
    new import_obsidian6.Setting(containerEl).setName("Auto-start Reading").setDesc("Automatically start reading after text loads.").addToggle((toggle) => toggle.setValue(this.plugin.settings.autoStart).onChange(async (value) => {
      this.plugin.settings.autoStart = value;
      await this.plugin.saveSettings();
    }));
    const autoStartDelaySetting = new import_obsidian6.Setting(containerEl).setName("Auto-start Delay").setDesc("Delay before auto-start (seconds).");
    this.createSliderWithInput(
      autoStartDelaySetting,
      1,
      10,
      1,
      this.plugin.settings.autoStartDelay,
      "s",
      async (value) => {
        this.plugin.settings.autoStartDelay = value;
        await this.plugin.saveSettings();
      }
    );
    new import_obsidian6.Setting(containerEl).setName("Keyboard Shortcuts").setHeading();
    containerEl.createEl("p", {
      text: "Note: hotkey customization is available in Obsidian's hotkeys settings.",
      cls: "setting-item-description"
    });
  }
};

// src/types.ts
var DEFAULT_SETTINGS = {
  wpm: 600,
  // Increased from 300 (inspired by Stutter: 400-800 range)
  chunkSize: 1,
  fontSize: 48,
  mobileFontSize: 32,
  minTokenFontSize: 12,
  mobileWpm: 600,
  mobileChunkSize: 1,
  mobileShowContext: false,
  mobileShowBreadcrumb: true,
  mobileEnableSlowStart: true,
  mobileEnableMicropause: true,
  contextLines: 0,
  mobileContextLines: 0,
  contextFontSize: 14,
  mobileContextFontSize: 14,
  highlightColor: "#4a9eff",
  backgroundColor: "#1e1e1e",
  fontColor: "#ffffff",
  fontFamily: "inherit",
  showContext: false,
  showBreadcrumb: true,
  enableMicropause: true,
  micropausePunctuation: 2.5,
  // Sentence-ending punctuation (.,!?) - Stutter-inspired
  micropauseOtherPunctuation: 1.5,
  // Other punctuation (;:,) - lighter pause
  micropauseLongWords: 1.4,
  // Words >8 chars - Stutter-inspired
  micropauseParagraph: 2.5,
  // Paragraph breaks - better section separation
  micropauseNumbers: 1.8,
  // Numbers and dates - comprehension aid
  micropauseSectionMarkers: 2,
  // Section numbers (1., I., etc.)
  micropauseListBullets: 1.8,
  // List bullets (-, *, +, •)
  micropauseCallouts: 2,
  // Obsidian callouts
  autoStart: false,
  autoStartDelay: 3,
  showProgress: true,
  hotkeyPlay: "Space",
  hotkeyRewind: "ArrowLeft",
  hotkeyForward: "ArrowRight",
  hotkeyIncrementWpm: "ArrowUp",
  hotkeyDecrementWpm: "ArrowDown",
  hotkeyQuit: "Escape",
  enableSlowStart: true,
  // Enable slow start by default
  enableAcceleration: false,
  accelerationDuration: 30,
  accelerationTargetWpm: 600
  // Increased from 450 (Stutter suggests 600-800)
};

// src/services/settings-validator.ts
var LIMITS2 = {
  wpm: { min: 50, max: 5e3 },
  chunkSize: { min: 1, max: 10 },
  fontSize: { min: 12, max: 120 },
  autoStartDelay: { min: 0, max: 60 },
  accelerationDuration: { min: 1, max: 300 },
  accelerationTargetWpm: { min: 50, max: 5e3 },
  micropauseMultiplier: { min: 1, max: 10 },
  contextLines: { min: 0, max: 10 },
  contextFontSize: { min: 10, max: 32 },
  // minimum font size for shrinking long single tokens
  minTokenFontSize: { min: 8, max: 120 }
};
function clamp(value, min, max) {
  return Math.max(min, Math.min(max, value));
}
function validateColor(color, defaultColor) {
  if (typeof color !== "string")
    return defaultColor;
  const c = color.trim();
  if (c === "" || c.toLowerCase() === "theme")
    return "";
  if (/^#([0-9A-Fa-f]{3}|[0-9A-Fa-f]{6})$/.test(c)) {
    return c;
  }
  return defaultColor;
}
function validateNumber(value, defaultValue, min, max) {
  if (typeof value !== "number" || isNaN(value)) {
    return defaultValue;
  }
  return clamp(value, min, max);
}
function validateBoolean(value, defaultValue) {
  if (typeof value === "boolean")
    return value;
  return defaultValue;
}
function validateString(value, defaultValue) {
  if (typeof value === "string")
    return value;
  return defaultValue;
}
function validateSettings(partial) {
  if (!partial || typeof partial !== "object") {
    return { ...DEFAULT_SETTINGS };
  }
  return {
    // Numeric settings with range validation
    wpm: validateNumber(
      partial.wpm,
      DEFAULT_SETTINGS.wpm,
      LIMITS2.wpm.min,
      LIMITS2.wpm.max
    ),
    chunkSize: validateNumber(
      partial.chunkSize,
      DEFAULT_SETTINGS.chunkSize,
      LIMITS2.chunkSize.min,
      LIMITS2.chunkSize.max
    ),
    fontSize: validateNumber(
      partial.fontSize,
      DEFAULT_SETTINGS.fontSize,
      LIMITS2.fontSize.min,
      LIMITS2.fontSize.max
    ),
    autoStartDelay: validateNumber(
      partial.autoStartDelay,
      DEFAULT_SETTINGS.autoStartDelay,
      LIMITS2.autoStartDelay.min,
      LIMITS2.autoStartDelay.max
    ),
    accelerationDuration: validateNumber(
      partial.accelerationDuration,
      DEFAULT_SETTINGS.accelerationDuration,
      LIMITS2.accelerationDuration.min,
      LIMITS2.accelerationDuration.max
    ),
    accelerationTargetWpm: validateNumber(
      partial.accelerationTargetWpm,
      DEFAULT_SETTINGS.accelerationTargetWpm,
      LIMITS2.accelerationTargetWpm.min,
      LIMITS2.accelerationTargetWpm.max
    ),
    // Micropause multipliers
    micropausePunctuation: validateNumber(
      partial.micropausePunctuation,
      DEFAULT_SETTINGS.micropausePunctuation,
      LIMITS2.micropauseMultiplier.min,
      LIMITS2.micropauseMultiplier.max
    ),
    micropauseOtherPunctuation: validateNumber(
      partial.micropauseOtherPunctuation,
      DEFAULT_SETTINGS.micropauseOtherPunctuation,
      LIMITS2.micropauseMultiplier.min,
      LIMITS2.micropauseMultiplier.max
    ),
    micropauseLongWords: validateNumber(
      partial.micropauseLongWords,
      DEFAULT_SETTINGS.micropauseLongWords,
      LIMITS2.micropauseMultiplier.min,
      LIMITS2.micropauseMultiplier.max
    ),
    micropauseParagraph: validateNumber(
      partial.micropauseParagraph,
      DEFAULT_SETTINGS.micropauseParagraph,
      LIMITS2.micropauseMultiplier.min,
      LIMITS2.micropauseMultiplier.max
    ),
    micropauseNumbers: validateNumber(
      partial.micropauseNumbers,
      DEFAULT_SETTINGS.micropauseNumbers,
      LIMITS2.micropauseMultiplier.min,
      LIMITS2.micropauseMultiplier.max
    ),
    micropauseSectionMarkers: validateNumber(
      partial.micropauseSectionMarkers,
      DEFAULT_SETTINGS.micropauseSectionMarkers,
      LIMITS2.micropauseMultiplier.min,
      LIMITS2.micropauseMultiplier.max
    ),
    micropauseListBullets: validateNumber(
      partial.micropauseListBullets,
      DEFAULT_SETTINGS.micropauseListBullets,
      LIMITS2.micropauseMultiplier.min,
      LIMITS2.micropauseMultiplier.max
    ),
    micropauseCallouts: validateNumber(
      partial.micropauseCallouts,
      DEFAULT_SETTINGS.micropauseCallouts,
      LIMITS2.micropauseMultiplier.min,
      LIMITS2.micropauseMultiplier.max
    ),
    mobileFontSize: validateNumber(
      partial.mobileFontSize,
      DEFAULT_SETTINGS.mobileFontSize,
      LIMITS2.fontSize.min,
      LIMITS2.fontSize.max
    ),
    minTokenFontSize: validateNumber(
      partial.minTokenFontSize,
      DEFAULT_SETTINGS.minTokenFontSize,
      LIMITS2.minTokenFontSize.min,
      LIMITS2.minTokenFontSize.max
    ),
    mobileWpm: validateNumber(
      partial.mobileWpm,
      DEFAULT_SETTINGS.mobileWpm,
      LIMITS2.wpm.min,
      LIMITS2.wpm.max
    ),
    mobileChunkSize: validateNumber(
      partial.mobileChunkSize,
      DEFAULT_SETTINGS.mobileChunkSize,
      LIMITS2.chunkSize.min,
      LIMITS2.chunkSize.max
    ),
    contextLines: validateNumber(
      partial.contextLines,
      DEFAULT_SETTINGS.contextLines,
      LIMITS2.contextLines.min,
      LIMITS2.contextLines.max
    ),
    mobileContextLines: validateNumber(
      partial.mobileContextLines,
      DEFAULT_SETTINGS.mobileContextLines,
      LIMITS2.contextLines.min,
      LIMITS2.contextLines.max
    ),
    contextFontSize: validateNumber(
      partial.contextFontSize,
      DEFAULT_SETTINGS.contextFontSize,
      LIMITS2.contextFontSize.min,
      LIMITS2.contextFontSize.max
    ),
    mobileContextFontSize: validateNumber(
      partial.mobileContextFontSize,
      DEFAULT_SETTINGS.mobileContextFontSize,
      LIMITS2.contextFontSize.min,
      LIMITS2.contextFontSize.max
    ),
    // Color settings
    highlightColor: validateColor(partial.highlightColor, DEFAULT_SETTINGS.highlightColor),
    backgroundColor: validateColor(partial.backgroundColor, DEFAULT_SETTINGS.backgroundColor),
    fontColor: validateColor(partial.fontColor, DEFAULT_SETTINGS.fontColor),
    // String settings
    fontFamily: validateString(partial.fontFamily, DEFAULT_SETTINGS.fontFamily),
    hotkeyPlay: validateString(partial.hotkeyPlay, DEFAULT_SETTINGS.hotkeyPlay),
    hotkeyRewind: validateString(partial.hotkeyRewind, DEFAULT_SETTINGS.hotkeyRewind),
    hotkeyForward: validateString(partial.hotkeyForward, DEFAULT_SETTINGS.hotkeyForward),
    hotkeyIncrementWpm: validateString(partial.hotkeyIncrementWpm, DEFAULT_SETTINGS.hotkeyIncrementWpm),
    hotkeyDecrementWpm: validateString(partial.hotkeyDecrementWpm, DEFAULT_SETTINGS.hotkeyDecrementWpm),
    hotkeyQuit: validateString(partial.hotkeyQuit, DEFAULT_SETTINGS.hotkeyQuit),
    // Boolean settings
    showContext: validateBoolean(partial.showContext, DEFAULT_SETTINGS.showContext),
    showBreadcrumb: validateBoolean(partial.showBreadcrumb, DEFAULT_SETTINGS.showBreadcrumb),
    enableMicropause: validateBoolean(partial.enableMicropause, DEFAULT_SETTINGS.enableMicropause),
    autoStart: validateBoolean(partial.autoStart, DEFAULT_SETTINGS.autoStart),
    showProgress: validateBoolean(partial.showProgress, DEFAULT_SETTINGS.showProgress),
    enableSlowStart: validateBoolean(partial.enableSlowStart, DEFAULT_SETTINGS.enableSlowStart),
    enableAcceleration: validateBoolean(partial.enableAcceleration, DEFAULT_SETTINGS.enableAcceleration),
    mobileShowContext: validateBoolean(partial.mobileShowContext, DEFAULT_SETTINGS.mobileShowContext),
    mobileShowBreadcrumb: validateBoolean(partial.mobileShowBreadcrumb, DEFAULT_SETTINGS.mobileShowBreadcrumb),
    mobileEnableSlowStart: validateBoolean(partial.mobileEnableSlowStart, DEFAULT_SETTINGS.mobileEnableSlowStart),
    mobileEnableMicropause: validateBoolean(partial.mobileEnableMicropause, DEFAULT_SETTINGS.mobileEnableMicropause)
  };
}

// main.ts
var DashReaderPlugin = class extends import_obsidian7.Plugin {
  constructor() {
    super(...arguments);
    this.currentModal = null;
    this.skipInitialAutoLoad = false;
  }
  async onload() {
    await this.loadSettings();
    this.addRibbonIcon("zap", "Launch speed-reader from curser", () => {
      void this.openModal();
    });
    this.addCommand({
      id: "open",
      name: "Launch from curser",
      callback: () => {
        void this.openModal();
      }
    });
    this.addCommand({
      id: "read-selection",
      name: "Read selected text",
      editorCallback: (editor) => {
        var _a;
        const selection = editor.getSelection();
        if (selection) {
          const modal = this.openModal({ skipInitialAutoLoad: true });
          const fileName = (_a = this.app.workspace.getActiveFile()) == null ? void 0 : _a.name;
          const lineNumber = editor.getCursor().line + 1;
          modal.loadText(selection, { fileName, lineNumber });
        } else {
          new import_obsidian7.Notice("Please select some text first");
        }
      }
    });
    this.addCommand({
      id: "read-note",
      name: "Read entire note",
      callback: () => {
        var _a, _b, _c;
        const activeView = this.app.workspace.getActiveViewOfType(import_obsidian7.MarkdownView);
        if (activeView) {
          const content = activeView.editor.getValue();
          const fileName = (_c = (_a = activeView.file) == null ? void 0 : _a.name) != null ? _c : (_b = this.app.workspace.getActiveFile()) == null ? void 0 : _b.name;
          const modal = this.openModal({ skipInitialAutoLoad: true });
          modal.loadText(content, { fileName, lineNumber: 1 });
        } else {
          new import_obsidian7.Notice("No active note found");
        }
      }
    });
    this.registerEvent(
      this.app.workspace.on("editor-menu", (menu, editor) => {
        const selection = editor.getSelection();
        if (selection) {
          menu.addItem((item) => {
            item.setTitle("Read with speed reader").setIcon("zap").onClick(() => {
              const modal = this.openModal({ skipInitialAutoLoad: true });
              modal.loadText(selection);
            });
          });
        }
      })
    );
    this.addSettingTab(new DashReaderSettingTab(this.app, this));
    this.registerEvent(
      this.app.workspace.on("layout-change", () => {
        if (this.currentModal && this.currentModal.isOpen) {
          this.currentModal.updateSettings(this.settings);
        }
      })
    );
  }
  onunload() {
    if (this.currentModal) {
      this.currentModal.close();
      this.currentModal = null;
    }
  }
  async loadSettings() {
    const rawSettings = await this.loadData();
    this.settings = validateSettings(rawSettings);
    if (!rawSettings) {
      await this.saveData(this.settings);
    }
  }
  async saveSettings() {
    await this.saveData(this.settings);
    if (this.currentModal && this.currentModal.isOpen) {
      this.currentModal.updateSettings(this.settings);
    }
  }
  openModal(options) {
    if (this.currentModal && this.currentModal.isOpen)
      return this.currentModal;
    if (this.currentModal)
      this.currentModal.close();
    this.currentModal = new DashReaderView(
      this.app,
      this.settings,
      () => {
        this.currentModal = null;
      },
      () => void this.saveSettings()
    );
    if (options == null ? void 0 : options.skipInitialAutoLoad) {
      this.currentModal.requestSkipInitialAutoLoadOnce();
    }
    this.currentModal.open();
    return this.currentModal;
  }
};
